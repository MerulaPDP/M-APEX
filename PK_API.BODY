create or replace PACKAGE BODY PK_API IS
 
G_TIMEZONE VARCHAR2(10);
 
PROCEDURE USE_LOG
 (P_SIT_ID IN VARCHAR2
 ,P_USE_ID IN VARCHAR2 := null
 ,P_PRO_ID IN NUMBER := null
 ,P_TYPE IN VARCHAR2
 ,P_MESSAGE IN VARCHAR2 := null
 );
FUNCTION AUTHENTICATE
 RETURN VARCHAR2;
FUNCTION GENERATE_SESSION
 RETURN VARCHAR2;
FUNCTION SESSION_VALID
 RETURN BOOLEAN;
FUNCTION GET_CONTEXT
 RETURN INTEGER;
PROCEDURE GET_PICTURE;
FUNCTION UPLOAD_FILE
 (P_FILE IN BLOB
 ,P_MIMETYPE IN VARCHAR2
 ,P_FILENAME IN VARCHAR2
 )
 RETURN VARCHAR2;
PROCEDURE DOWNLOAD_FILE;
FUNCTION GET_FILE_LIST
 RETURN CLOB;
FUNCTION ADD_FILES
 RETURN VARCHAR2;
FUNCTION REMOVE_FILES
 RETURN VARCHAR2;
FUNCTION GET_DOCUMENT_GROUP_LIST
 RETURN CLOB;
FUNCTION ADD_DOCUMENT_GROUPS
 RETURN VARCHAR2;
FUNCTION REMOVE_DOCUMENT_GROUPS
 RETURN VARCHAR2;
FUNCTION GET_ATTACHED_DOCUMENT_GROUPS
 RETURN CLOB;
FUNCTION LOGIN
 RETURN CLOB;
FUNCTION CHECK_CREDENTIALS
 (P_EMAIL IN VARCHAR2
 ,P_PASSWORD IN VARCHAR2
 )
 RETURN NUMBER;
FUNCTION LOGOUT
 RETURN VARCHAR2;
FUNCTION GET_USER_ACTIVITY
 RETURN CLOB;
FUNCTION GET_USER_INFO
 RETURN CLOB;
FUNCTION GET_USER_PROJECTS
 RETURN CLOB;
FUNCTION GET_PROJECT_INFO
 RETURN CLOB;
FUNCTION GET_PROCESS_START_INFO
 RETURN CLOB;
FUNCTION START_PROCESS
 RETURN CLOB;
FUNCTION GET_USER_PROJECT_TASKS
 RETURN CLOB;
FUNCTION GET_USER_PROJECT_ALERTS
 RETURN CLOB;
FUNCTION GET_USER_PROJECT_SHARED
 RETURN CLOB;
FUNCTION GET_USER_PROJECT_NEWS
 RETURN CLOB;
FUNCTION GET_USER_PROJECT_TRACKING
 RETURN CLOB;
FUNCTION EXECUTE_TASK
 RETURN VARCHAR2;
FUNCTION UPDATE_PROCESS
 RETURN CLOB;
FUNCTION GET_NEXT_TASK_INFO
 RETURN CLOB;
FUNCTION GET_USER_PROJECT_PROCESSES
 RETURN CLOB;
FUNCTION DISMISS_USER_TASK
 RETURN VARCHAR2;
FUNCTION SET_TASK_SHARE_USERS
 RETURN VARCHAR2;
FUNCTION GET_PROJECT_PACKAGES
 RETURN CLOB;
FUNCTION GET_PACKAGE_INFO
 RETURN CLOB;
FUNCTION GET_PACKAGE_DOCUMENTS
 RETURN CLOB;
FUNCTION GET_PROJECT_COMPANIES
 RETURN CLOB;
FUNCTION GET_GRAPH_DATA
 RETURN CLOB;
 
PROCEDURE REQUEST
 (P_MESSAGE IN VARCHAR2
 ,P_FILE IN BLOB := null
 ,P_MIMETYPE IN VARCHAR2 := null
 ,P_FILENAME IN VARCHAR2 := null
 )
 IS
-- Parse request, committing by mod/plsql
 
  l_response      CLOB;       
  l_ind_log  VARCHAR2(1):= SUBSTR(pk_glob.get_para('IND_API_LOG'),1,1); -- Y: all xml requests and responses should be logged
BEGIN
 
  -- Logging
  g_module   := 'pk_api.request';
  
  -- Init/check parameters/globals   (evt rel,pro,sit FK check)
  g_location := '1';
  g_message  := SUBSTR(p_message,1,10000);
  g_cmd      := lower(pk_xml_api.get_tag_data(g_message,'<cmd>'));
  g_session_string := pk_xml_api.get_tag_data(g_message,'<session_string>');
  g_use_id   := TO_NUMBER(pk_xml_api.get_tag_data(g_message,'<use_id>'));
  g_pro_id   := TO_NUMBER(pk_xml_api.get_tag_data(g_message,'<pro_id>'));
  g_sit_id   := TO_NUMBER(pk_xml_api.get_tag_data(g_message,'<sit_id>'));
                                 
  -- NLS params goed zetten
  EXECUTE IMMEDIATE ('ALTER SESSION SET NLS_NUMERIC_CHARACTERS = ".,"');  -- decimal = . and thousends = ,
 
  -- Timezone
  IF g_cmd <> 'authenticate' THEN
    SELECT timezone 
    INTO g_timezone
    FROM web_sessions 
    WHERE session_string = g_session_string;   
    
/*  IF to_number(substr(g_timezone,1,3)) - 6 < -12 THEN
       g_timezone := to_number(substr(g_timezone,1,3)) + 18|| ':00';      -- tijdelijke correctie    
    ELSE
       g_timezone := to_number(substr(g_timezone,1,3)) - 6 || ':00';      -- tijdelijke correctie    
    END IF;
*/       
    EXECUTE IMMEDIATE ('ALTER SESSION SET TIME_ZONE='''||g_timezone||'''');  
  
  END IF;  
      
  -- Security / Authentication
  g_location := '2';
  IF    g_cmd = 'get_context'
        OR
        (  (
             ( g_session_string IS NULL AND g_cmd = 'authenticate' )
              OR
              pk_api.session_valid
            )
            AND
            g_sit_id IS NOT NULL
        )
 
   THEN
       -- Checks for cmds where user is mandatory to be logged in
       IF NOT(g_cmd IN ( 'get_user_info', 'get_user_projects', 'get_project_info','get_user_activity'
                       , 'get_picture', 'upload_file', 'download_file','get_file_list','add_files','remove_files'  
                       , 'add_document_groups','get_document_group_list','remove_document_groups'   
                       , 'get_attached_document_groups'
                       , 'get_process_start_info', 'start_process', 'get_user_project_tasks'  
                       , 'get_user_project_alerts', 'get_user_project_shared', 'get_user_project_news', 'get_user_project_tracking'
                       , 'get_timeline', 'get_task_info', 'get_process_info', 'get_user_project_processes'
                       , 'get_next_task_info', 'execute_task', 'update_process', 'dismiss_user_task','set_task_share_users'
                       , 'get_project_packages', 'get_package_info', 'get_package_documents', 'get_project_companies'
                       , 'get_graph_data')
          AND g_use_id IS NULL) THEN
 
           -- Parse het commando:
           g_location := '3';
 
           -- Security
           IF g_cmd = 'authenticate' THEN
             l_response := pk_api.authenticate;
           ELSIF g_cmd = 'login' THEN
             l_response := pk_api.login;
           ELSIF g_cmd = 'logout' THEN
             l_response := pk_api.logout;
 
           -- User
           ELSIF g_cmd = 'get_user_info' THEN
             l_response := pk_api.get_user_info;
           ELSIF g_cmd = 'get_user_projects' THEN
             l_response := pk_api.get_user_projects;     
           ELSIF g_cmd = 'get_user_activity' THEN
             l_response := pk_api.get_user_activity;
           
           -- Projects
           ELSIF g_cmd = 'get_project_info' THEN
             l_response := pk_api.get_project_info;
 
           -- Processes 
           ELSIF g_cmd = 'get_process_start_info' THEN
             l_response := pk_api.get_process_start_info;           
           ELSIF g_cmd = 'start_process' THEN
             l_response := pk_api.start_process; 
              
           ELSIF g_cmd = 'get_user_project_tasks' THEN
             l_response := pk_api.get_user_project_tasks;    
           ELSIF g_cmd = 'get_next_task_info' THEN
             l_response := pk_api.get_next_task_info;
           ELSIF g_cmd = 'execute_task' THEN
             l_response := pk_api.execute_task;
           ELSIF g_cmd = 'update_process' THEN
             l_response := pk_api.update_process;    
           ELSIF g_cmd = 'get_user_project_processes' THEN
             l_response := pk_api.get_user_project_processes;    
           
           -- special tasks  
           ELSIF g_cmd = 'get_user_project_alerts' THEN
             l_response := pk_api.get_user_project_alerts;
             
           ELSIF g_cmd = 'get_user_project_shared' THEN
             l_response := pk_api.get_user_project_shared;   
           ELSIF g_cmd = 'set_task_share_users' THEN
             l_response := pk_api.set_task_share_users;                  
                         
           ELSIF g_cmd = 'get_user_project_news' THEN
             l_response := pk_api.get_user_project_news;
           ELSIF g_cmd = 'get_user_project_tracking' THEN
             l_response := pk_api.get_user_project_tracking;   
           ELSIF g_cmd = 'dismiss_user_task' THEN
             l_response := pk_api.dismiss_user_task; 
             
           ELSIF g_cmd = 'get_timeline' THEN
             l_response := pk_api.get_timeline;
           ELSIF g_cmd = 'get_task_info' THEN
             l_response := pk_api.get_task_info;
           ELSIF g_cmd = 'get_process_info' THEN
             l_response := pk_api.get_process_info;
                                 
           -- project packages
           ELSIF g_cmd = 'get_project_packages' THEN
             l_response := pk_api.get_project_packages;
           ELSIF g_cmd = 'get_package_info' THEN
             l_response := pk_api.get_package_info;
           ELSIF g_cmd = 'get_package_documents' THEN
             l_response := pk_api.get_package_documents;
                                 
           -- project companies
           ELSIF g_cmd = 'get_project_companies' THEN
             l_response := pk_api.get_project_companies;
 
           -- Pictures and files
           ELSIF g_cmd = 'get_picture' THEN
             pk_api.get_picture;      -- Procedure, geen functie
           ELSIF g_cmd = 'download_file' THEN
             pk_api.download_file;         -- Procedure, geen functie                        
           ELSIF g_cmd = 'upload_file' THEN
             l_response := pk_api.upload_file(p_file     => p_file
                                             ,p_mimetype => p_mimetype
                                             ,p_filename => p_filename);
           ELSIF g_cmd = 'get_file_list' THEN
             l_response := pk_api.get_file_list;
           ELSIF g_cmd = 'add_files' THEN
             l_response := pk_api.add_files;
           ELSIF g_cmd = 'remove_files' THEN
             l_response := pk_api.remove_files;           
           -- document groups
           ELSIF g_cmd = 'get_document_group_list' THEN
             l_response := pk_api.get_document_group_list;           
           ELSIF g_cmd = 'add_document_groups' THEN
             l_response := pk_api.add_document_groups;
           ELSIF g_cmd = 'remove_document_groups' THEN
             l_response := pk_api.remove_document_groups;      
           ELSIF g_cmd = 'get_attached_document_groups' THEN
             l_response := pk_api.get_attached_document_groups;
           -- graph_data
           ELSIF g_cmd = 'get_graph_data' THEN
             l_response := pk_api.get_graph_data;
                          
           ELSE
             l_response := pk_xml_api.create_element('error','No valid command.');
             l_ind_log := 'Y'; -- Dit request in ieder geval loggen
           END IF;
 
      ELSE
         -- Not logged in
         l_response := pk_xml_api.create_element('error','Not logged in.');
      END IF;
 
  ELSE
    -- No session or site
    l_response := pk_xml_api.create_element('error','No valid session or site.');
    l_ind_log := 'Y'; -- Dit request in ieder geval loggen
  END IF;
 
  -- set module info back, errors from this point are in the request module
  g_module   := 'pk_api.request';
 
  -- Proloog en epiloog
  g_location := '4';
  l_response := '<?xml version="1.0" encoding="UTF-8"?>' ||
                pk_xml_api.create_element('reply',
                    l_response ||
                    pk_xml_api.create_element('security',
                         pk_xml_api.create_element('session_string',g_session_string) ||
                         pk_xml_api.create_element('use_id',g_use_id) ||
                         pk_xml_api.create_element('pro_id',g_pro_id) ||
                         pk_xml_api.create_element('sit_id',g_sit_id)
                                             )
                                          );
  -- Print response back, only for text based responses
  g_location := '5'; 
  IF g_cmd NOT IN( 'get_picture','upload_file','get_file') THEN      
    pk_util.p(l_response);
  END IF;                                 
  
  
  
  
  -- Update session timestamp
  g_location := '6';
  UPDATE web_sessions
  SET timestamp = sysdate
  WHERE session_string = g_session_string;
 
  -- Logging if necessary
  g_location := '7';
  IF l_ind_log = 'Y' THEN
    pk_api.sys_log( p_sit_id   => g_sit_id
                  , p_use_id   => g_use_id
                  , p_pro_id   => g_pro_id
                  , p_module   => g_module
                  , p_location => 'log'
                  , p_session_string => g_session_string
                  , p_type     => 'I' -- Api logging
                  , p_cmd      => g_cmd
                  , p_message  => NULL
                  , p_api_request  => g_message
                  , p_api_response => l_response 
                  );
  END IF;
 
EXCEPTION WHEN OTHERS THEN
 
  g_error_message := LTRIM(g_error_message || ' SQLERRM: ') || SQLERRM;
  pk_api.sys_log( p_sit_id   => g_sit_id
                , p_use_id   => g_use_id
                , p_pro_id   => g_pro_id
                , p_module   => g_module
                , p_location => g_location
                , p_session_string => g_session_string
                , p_type     => 'E' -- Error
                , p_cmd      => g_cmd
                , p_message  => g_error_message
                , p_api_request  => g_message
                , p_api_response => l_response
                );  
  
    -- Error logging
  pk_util.p('<?xml version="1.0" encoding="UTF-8"?>' || 
            pk_xml_api.create_element('reply'
                ,pk_xml_api.create_element('error','A system error was encountered. Contact support.')));
  
  -- If it was an upload_file error, propagete error to REST service
  IF g_cmd = 'upload_file' THEN 
    RAISE;
  END IF;  
                              
END;
PROCEDURE SYS_LOG
 (P_CMD IN VARCHAR2 := null
 ,P_SIT_ID IN NUMBER := null
 ,P_USE_ID IN NUMBER := null
 ,P_PRO_ID IN NUMBER := null
 ,P_MODULE IN VARCHAR2 := null
 ,P_LOCATION IN VARCHAR2 := null
 ,P_TYPE IN VARCHAR2
 ,P_SESSION_STRING IN VARCHAR2 := null
 ,P_MESSAGE IN VARCHAR2 := null
 ,P_API_REQUEST IN CLOB := empty_clob()
 ,P_API_RESPONSE IN CLOB := empty_clob()
 )
 IS
-- Logging of system related data:
--                   type
--   - systeemerrors  (E)
--   - api logs, info (I)
 
PRAGMA autonomous_transaction;
 
l_ip_address    VARCHAR2(100);
l_host_name     VARCHAR2(250);
BEGIN
 
  l_ip_address := SUBSTR(pk_apex_security.get_ip_address,1,100);
  l_host_name  := SUBSTR(pk_apex_security.get_host_name(l_ip_address),1,250);
 
  INSERT INTO api_log
    ( id
    , sit_id
    , use_id
    , pro_id
    , module
    , location
    , session_string
    , type
    , cmd
    , message
    , ip_address
    , host_name
    , api_request
    , api_response)
    VALUES ( seq_log.nextval
           , NVL(p_sit_id,g_sit_id)
           , NVL(p_use_id,g_use_id)
           , NVL(p_pro_id,g_pro_id)
           , SUBSTR(p_module,1,250)
           , SUBSTR(p_location,1,250)
           , SUBSTR(NVL(p_session_string,g_session_string),1,250)
           , p_type
           , SUBSTR(NVL(p_cmd,g_cmd),1,250)
           , p_message
           , l_ip_address
           , l_host_name
           , p_api_request
           , p_api_response );
 
    COMMIT;
 
END;
PROCEDURE USE_LOG
 (P_SIT_ID IN VARCHAR2
 ,P_USE_ID IN VARCHAR2 := null
 ,P_PRO_ID IN NUMBER := null
 ,P_TYPE IN VARCHAR2
 ,P_MESSAGE IN VARCHAR2 := null
 )
 IS
-- Logging of user/site activity:
--                    type
--   - Log in         (I)
--   - Log out        (U)
--  
 
PRAGMA autonomous_transaction;
 
l_ip_address    VARCHAR2(100);
l_host_name     VARCHAR2(250);
BEGIN
 
  l_ip_address := SUBSTR(pk_apex_security.get_ip_address,1,100);
  l_host_name  := SUBSTR(pk_apex_security.get_host_name(l_ip_address),1,250);
 
  g_location := '2';
  INSERT INTO use_log
    ( sit_id
    , use_id
    , pro_id
    , type
    , message
    , ip_address
    , host_name )
    VALUES ( p_sit_id
           , NVL(p_use_id,g_use_id)
           , NVL(p_pro_id,g_pro_id)
           , p_type
           , SUBSTR(p_message,1,4000)
           , l_ip_address
           , l_host_name );
 
    COMMIT;
   
END;
FUNCTION AUTHENTICATE
 RETURN VARCHAR2
 IS
-- Authenticate
-- Make a sessionstring
 
l_ip_address VARCHAR2(100); 
l_timezone   VARCHAR2(10);  
l_dummy      NUMBER;
l_host_name  VARCHAR2(250);
l_sit_id     NUMBER;
BEGIN
 
  -- Init
  g_module   := 'pk_api.authenticate';
  g_location := '1';
  
  l_ip_address := SUBSTR(pk_xml_api.get_tag_data(g_message,'<ip_address>'),1,100);    
  l_timezone := SUBSTR(pk_xml_api.get_tag_data(g_message,'<timezone>'),1,10);  
  l_host_name  := SUBSTR(pk_apex_security.get_host_name(l_ip_address),1,250);
  
  -- Controleer sit_id
  BEGIN
    SELECT 1
    INTO l_sit_id
    FROM web_sites
    WHERE id = g_sit_id;
  EXCEPTION WHEN OTHERS THEN
     RETURN pk_xml_api.create_element('error','Invalid site.');
  END;
  
  -- Check Timezone format: +nnnn
  BEGIN
    l_dummy := TO_NUMBER(SUBSTR(l_timezone,2,2));
    l_dummy := TO_NUMBER(SUBSTR(l_timezone,4,2));
  EXCEPTION WHEN OTHERS THEN
     RETURN pk_xml_api.create_element('error','Invalid timezone numbers.');
  END;   
  
  IF SUBSTR(l_timezone,1,1) NOT IN ('+','-') THEN
     RETURN pk_xml_api.create_element('error','Invalid timezone sign.');
  END IF;  
  
  l_timezone := SUBSTR(l_timezone,1,3)||':'||SUBSTR(l_timezone,4,2);
  
  -- Not logged in
  IF g_session_string IS NULL AND g_use_id IS NULL AND g_pro_id IS NULL AND l_ip_address IS NOT NULL AND l_timezone IS NOT NULL THEN
 
      -- Nieuwe sessie
      g_location := '2';
      g_session_string := pk_api.generate_session;
      INSERT INTO web_sessions
       ( session_string
       , sit_id
       , ip_address
       , timezone
       , host_name ) VALUES
         ( g_session_string
         , g_sit_id
         , l_ip_address 
         , l_timezone
         , l_host_name);
         
      COMMIT;
 
      -- Result
      RETURN pk_xml_api.create_element('result','Ok.');
 
  ELSE
 
     g_location := '3';
     RETURN pk_xml_api.create_element('error','Invalid parameters.');
 
  END IF;
 
END;
FUNCTION GENERATE_SESSION
 RETURN VARCHAR2
 IS
-- generate a new session string
 
  l_seed    NUMBER;
BEGIN
 
  -- randomly reseed
  IF ROUND(dbms_random.value(0,10)) = 1 THEN
    dbms_random.initialize(to_number(to_char(sysdate,'SSSSS')));
  END IF;
 
  -- Return the generated session
  RETURN dbms_random.string('x',30);
 
END;
FUNCTION SESSION_VALID
 RETURN BOOLEAN
 IS
-- Check session
 
 l_dummy  NUMBER;
 l_use_id NUMBER;
BEGIN
 
-- Init
g_module   := 'pk_api.session_valid';
g_location := '1';
 
-- Session_string exists?
g_location := '2';
SELECT 1
,      use_id
INTO l_dummy
,    l_use_id
FROM web_sessions ses
WHERE ses.session_string = g_session_string;
 
-- Check user
g_location := '3';
IF g_use_id IS NULL THEN
   IF l_use_id IS NULL THEN
     RETURN TRUE;  -- normal anonymous session 
   ELSE 
     RETURN FALSE; -- session_string used by a user, no user in message 
   END IF;  
END IF; 
 
-- at this point use_id IS NOT NULL
 
-- no project   
IF g_pro_id IS NULL THEN   
   -- Existing session for this user and site?
   g_location := '4';
   SELECT 1
   INTO l_dummy
   FROM web_sessions ses
   WHERE ses.session_string = g_session_string
   AND   ses.use_id = g_use_id
   AND   ses.sit_id = g_sit_id;
 
-- project 
ELSE
  -- 
   g_location := '5';
   SELECT 1
   INTO l_dummy
   FROM web_sessions  ses
   ,    user_projects usp
   WHERE ses.session_string = g_session_string
   AND   ses.use_id = g_use_id
   AND   ses.sit_id = g_sit_id
   AND   ses.use_id = usp.use_id
   AND   usp.pro_id = g_pro_id; -- to do: project and user_project active check
    
END IF;
 
-- All checks went well
RETURN TRUE;
 
EXCEPTION WHEN OTHERS THEN
 
  -- Error with into: no_data_found
  -- Session / pro_id / use_id / sit_id / 
  pk_api.sys_log( p_sit_id   => g_sit_id
                , p_use_id   => g_use_id
                , p_pro_id   => g_pro_id
                , p_module   => g_module
                , p_location => g_location
                , p_session_string => g_session_string
                , p_type     => 'E' -- Error
                , p_cmd      => g_cmd
                , p_message  => g_error_message
                , p_api_request => g_message
                );
 
  --Session can be deleted here if exists for security!
 
  RETURN FALSE;
 
END;
FUNCTION GET_CONTEXT
 RETURN INTEGER
 IS
--Return the context, based on session_string
BEGIN
  RETURN null;
END;
PROCEDURE GET_PICTURE
 IS
-- get picture                          
--https://apex1.revion.com/pls/apex/pdp.pk_file.get_file?p_table=users&p_column=picture&p_id=125
 
 
 l_id   NUMBER;
 l_type VARCHAR2(20);  
 l_table             VARCHAR2(100);
 l_column            VARCHAR2(100);
 l_filename_column   VARCHAR2(100); 
 l_filename          VARCHAR2(250);
 l_mimetype_column   VARCHAR2(100);
 l_mimetype          VARCHAR2(250);
 
 l_lob_loc    BLOB;
 l_sql_stmt   VARCHAR2(1000);  
 l_length     NUMBER;
 
 l_default_picture_name VARCHAR2(100);
BEGIN                           
 
 -- Init
 g_module   := 'pk_api.get_picture';
 g_location := '1';
 
 l_id   := TO_NUMBER(pk_xml_api.get_tag_data(g_message,'<id>'));
 l_type := lower(substr(pk_xml_api.get_tag_data(g_message,'<type>'),1,20));
 
 l_length := 0;
 
 IF l_id IS NOT NULL AND l_type IS NOT NULL THEN
 
    -- Type 
    IF l_type = 'user' THEN
       l_table           := 'users';  
       l_column          := 'picture_thumbnail';  
       l_filename_column := 'filename'; 
       l_mimetype_column := 'mimetype';  
    ELSIF l_type = 'project' THEN
       l_table           := 'projects';
       l_column          := 'picture';   
       l_filename_column := 'filename';       
       l_mimetype_column := 'mimetype';
    END IF;
    
    IF l_table IS NOT NULL THEN
      -- sql statement for blob column  
      BEGIN 
        l_sql_stmt := 'SELECT ' || l_column || ' ' ||
                      ',      ' || l_filename_column || ' ' ||      
                      ',      ' || l_mimetype_column || ' ' ||                   
                      'FROM ' || l_table || ' ' ||
                      'WHERE id = ' || TO_CHAR(l_id) ;
        g_location := '2';  
        EXECUTE IMMEDIATE l_sql_stmt INTO l_lob_loc
                                     ,    l_filename
                                     ,    l_mimetype;   
        l_length := dbms_lob.getlength(l_lob_loc);
      EXCEPTION WHEN OTHERS THEN
       NULL;
      END;
      
    END IF;
 
 END IF;  
 
 -- default pictures
 IF l_length = 0 OR l_length IS NULL THEN  
   
   IF l_type = 'user' THEN
     l_default_picture_name := 'default_picture_nouser';
   ELSE
     l_default_picture_name := 'default_picture_noproject';
   END IF;
   
   SELECT picture
   ,      filename
   INTO l_lob_loc
   ,    l_filename
   FROM system_pictures
   WHERE UPPER(name) = UPPER(l_default_picture_name);    
    
 END IF;          
           
 g_location := '3';     
 
 pk_file.get( p_filename => l_filename
            , p_file     => l_lob_loc
            , p_mimetype => l_mimetype );
 
EXCEPTION WHEN OTHERS THEN
  null;     
END;
FUNCTION UPLOAD_FILE
 (P_FILE IN BLOB
 ,P_MIMETYPE IN VARCHAR2
 ,P_FILENAME IN VARCHAR2
 )
 RETURN VARCHAR2
 IS
-- File Upload
-- based on tin or pin
-- tin is for task specific documents, e.g. a photo
-- pin is for process documents and remain connected to the originating table, via ctx, not the process
 
-- insert record in document_groups
-- to do: more generic, indicator in process table when to insert it, also the cursor should be more generic
 
-- insert record into doc_com for initial security
 
 
l_pin_id NUMBER  := TO_NUMBER(pk_xml_api.get_tag_data(g_message,'<pin_id>')); 
l_tin_id NUMBER  := TO_NUMBER(pk_xml_api.get_tag_data(g_message,'<tin_id>'));
l_pw     NUMBER  := TO_NUMBER(pk_xml_api.get_tag_data(g_message,'<pw>'));
l_ph     NUMBER  := TO_NUMBER(pk_xml_api.get_tag_data(g_message,'<ph>'));
l_mimetype  VARCHAR2(255) := SUBSTR(pk_xml_api.get_tag_data(g_message,'<mimetype>'),1,255);     
l_comment   VARCHAR2(4000):= SUBSTR(pk_xml_api.get_tag_data(g_message,'<comment>'),1,4000);
 
l_file      BLOB;
l_doc_size  NUMBER;
l_doc_id    NUMBER;
l_com_id    NUMBER;
l_dgr_id    NUMBER;
 
l_response  VARCHAR2(1000);
 
CURSOR c_tin IS
  SELECT tin.id             tin_id
  ,      tin.date_finished  date_finished
  FROM task_instances    tin
  WHERE tin.id = l_tin_id;
r_tin c_tin%ROWTYPE;  
 
-- later: this cursor must be more generic
CURSOR c_dap IS
  SELECT dap.dot_id
  ,      dap.subject
  ,      dap.doc_number
  ,      dap.revision_number
  FROM document_approvals  dap           
  ,    process_instances   pin
  WHERE  dap.id = pin.ctx_id
  AND    pin.id = l_pin_id;
r_dap c_dap%ROWTYPE;
 
CURSOR c_pin IS
  SELECT pin.id             pin_id
  ,      pin.date_finished  date_finished
  ,      pin.ctx_id         ctx_id
  ,      proc.ctx_table     ctx_table
  FROM process_instances pin
  ,    processes         proc
  WHERE pin.id = l_pin_id
  AND   pin.proc_id = proc.id;
r_pin c_pin%ROWTYPE;  
  
CURSOR c_com IS
  SELECT use.com_id
  FROM users use
  WHERE use.id = g_use_id;  
 
-- document group info
CURSOR c_dgr (b_ctx_table IN VARCHAR2, b_ctx_id IN VARCHAR2) IS
  SELECT dgr.id
  FROM document_groups dgr
  WHERE dgr.ctx_table = b_ctx_table
  AND   dgr.ctx_id    = b_ctx_id;
BEGIN    
 
  -- Init
  g_module   := 'pk_api.upload_file';
  g_location := '1';
  
  -- company
  OPEN c_com;
  FETCH c_com INTO l_com_id;
  CLOSE c_com;
  
  -- Blob init
  l_file := p_file;
  l_doc_size := dbms_lob.getlength(l_file);
 
  -- Scaling in case of picture
  IF l_pw IS NOT NULL AND l_ph IS NOT NULL THEN
     ordimage.process(l_file, 'maxScale = '||l_pw||' '||l_ph||'');
  END IF;
  
  -- process upload, DA, ECT II for instance
  IF l_pin_id IS NOT NULL THEN  
    
    -- process info
    OPEN c_pin;
    FETCH c_pin INTO r_pin;
    CLOSE c_pin;
    
    -- check process
    IF r_pin.pin_id IS NULL THEN 
      raise_application_error(-20001,'No correct process found.');    
    END IF; 
    IF r_pin.date_finished IS NOT NULL THEN
      raise_application_error(-20001,'Process already finished.');
    END IF;
    
    -- insert document group
    -- later: vinkje in de processes tabel opnemen of data in een groep moet worden opgenomen
    IF lower(r_pin.ctx_table) = 'document_approvals' THEN
       
       -- check if group exists
       OPEN c_dgr(b_ctx_table => r_pin.ctx_table
                 ,b_ctx_id    => r_pin.ctx_id);
       FETCH c_dgr INTO l_dgr_id;
       CLOSE c_dgr;
       
       -- If no similar group is found, create a new one
       IF l_dgr_id IS NULL THEN
          l_dgr_id := seq_all.nextval;
       
         OPEN c_dap;
         FETCH c_dap INTO r_dap;
         CLOSE c_dap;
        
         INSERT INTO document_groups
          ( id 
          , pro_id
          , dot_id
           , doc_number
          , revision_number
          , subject
          , ctx_table
          , ctx_id 
          , timestamp ) VALUES
            ( l_dgr_id
            , g_pro_id
            , r_dap.dot_id 
            , r_dap.doc_number
            , r_dap.revision_number
            , r_dap.subject
            , r_pin.ctx_table
            , r_pin.ctx_id
            , sysdate );      
       END IF;  
    
    END IF;
    
    -- insert document     
    g_location := '2';
    l_doc_id := seq_all.nextval;    
    INSERT INTO documents
        ( id
        , dgr_id
        , pro_id 
        , use_id  
        , ctx_table
        , ctx_id
        , timestamp
        , document
        , doc_comment
        , mimetype
        , filename
        , doc_size ) VALUES
           ( l_doc_id
           , l_dgr_id    -- optional, could be null
           , g_pro_id
           , g_use_id          
           , r_pin.ctx_table
           , r_pin.ctx_id
           , sysdate
           , l_file  
           , l_comment
           , SUBSTR(NVL(p_mimetype,l_mimetype),1,255)
           , SUBSTR(p_filename,1,400)
           , l_doc_size ); 
           
    -- insert security record
    INSERT INTO company_documents 
      ( id
      , doc_id
      , com_id ) VALUES
         ( seq_all.nextval
         , l_doc_id
         , l_com_id );
    
  ELSIF l_tin_id IS NOT NULL THEN       
    
    -- task info
    OPEN c_tin;
    FETCH c_tin INTO r_tin;
    CLOSE c_tin; 
    
    -- check task
    IF r_tin.tin_id IS NULL THEN 
      raise_application_error(-20001,'No correct task found.');    
    END IF; 
    IF r_pin.date_finished IS NOT NULL THEN
      raise_application_error(-20001,'Task already finished.');
    END IF;
    
    -- insert document
    g_location := '2';    
    INSERT INTO tin_documents
        ( id 
        , tin_id
        , timestamp
        , document
        , doc_comment
        , mimetype
        , filename
        , doc_size ) VALUES
           ( seq_all.nextval
           , l_tin_id
           , sysdate
           , l_file  
           , l_comment
           , SUBSTR(NVL(p_mimetype,l_mimetype),1,255)
           , SUBSTR(p_filename,1,400)
           , l_doc_size );
    
  ELSE        
    -- error
    raise_application_error(-20001,'Pin_id or tin_id must be provided.');    
  END IF;
  
  COMMIT;
    
  -- Resultaat 
  RETURN 'ok';    
 
 END;
PROCEDURE DOWNLOAD_FILE
 IS
-- download a file, tin (ad hoc) and pin (via process)
-- to do: security i.c.m. pin:company_documents, tin
 
 l_id   NUMBER;
 l_type VARCHAR2(20);   -- tin or pin
 l_ind_access VARCHAR2(1) := 'N';
 
 l_file BLOB;
 l_filename VARCHAR2(400);
 l_mimetype VARCHAR2(255);  
 
 -- security for pin: company of users must have access
 CURSOR c_cod IS
   SELECT 'Y'
   FROM company_documents cod
   ,    users             use 
   WHERE cod.doc_id = l_id
   AND   use.com_id = cod.com_id;
 
 -- security for tin: project must be current project of user, more checks?
 CURSOR c_tin IS
   SELECT 'Y'
   FROM tin_documents     tdo
   ,    task_instances    tin      
   ,    process_instances pin
   WHERE tdo.id = l_id
   AND   tin.id = tdo.tin_id 
   AND   tin.pin_id = pin.id
   AND   pin.pro_id = g_pro_id;
 
 -- tin document
 CURSOR c_tdo IS
   SELECT tdo.document
   ,      tdo.filename
   ,      tdo.mimetype
   FROM tin_documents tdo
   WHERE tdo.id = l_id;
 
 -- pin document
 CURSOR c_doc IS
   SELECT doc.document
   ,      doc.filename
   ,      doc.mimetype
   FROM documents doc
   WHERE doc.id = l_id;
BEGIN
 
 -- Init
 g_module   := 'pk_api.download_file';
 g_location := '1';
 
 l_id   := TO_NUMBER(pk_xml_api.get_tag_data(g_message,'<id>'));
 l_type := UPPER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<type>'),1,20));
 
 IF l_type = 'PIN' THEN
   -- check security in company_documents table 
   OPEN c_cod;
   FETCH c_cod INTO l_ind_access;
   CLOSE c_cod;
   
   IF l_ind_access = 'Y' THEN
     -- get document 
     OPEN c_doc;
     FETCH c_doc INTO l_file
                 ,    l_filename
                 ,    l_mimetype;
     CLOSE c_doc;            
   END IF;  
    
    
 ELSIF l_type = 'TIN' THEN
   -- check security 
   OPEN c_tin;
   FETCH c_tin INTO l_ind_access;
   CLOSE c_tin;
   
   IF l_ind_access = 'Y' THEN
     -- get document 
     OPEN c_tdo;
     FETCH c_tdo INTO l_file
                 ,    l_filename
                 ,    l_mimetype;
     CLOSE c_tdo;            
   END IF;
    
 END IF;   
 
-- get the document
IF l_ind_access = 'Y' THEN
  pk_file.get( p_filename => l_filename
             , p_file     => l_file
             , p_mimetype => l_mimetype );    
END IF;
 
EXCEPTION WHEN OTHERS THEN
  null;     
END;
FUNCTION GET_FILE_LIST
 RETURN CLOB
 IS
-- Get a file list
 
-- to do: security Is a user allowed to see these documents      
-- limit now to pro_id only?
 
l_response              CLOB;  
l_response_doc_pin      CLOB;  
l_response_doc_all      CLOB;  
l_response_doc_attached CLOB;  
 
l_count_doc_pin      NUMBER := 0;
l_count_doc_all      NUMBER := 0;
l_count_doc_attached NUMBER := 0;
 
--pin_id:
--  all uploaded documents in pin
--  all attached documents in pin
 
--no pin_id:
--  all_uploaded documents per pin 
--  no attached documents
 
l_pin_id       NUMBER;
 
-- uploaded docs for a specific pin
CURSOR c_doc_pin IS
  SELECT doc.id
  ,      doc.filename
  ,      doc.doc_size
  ,      doc.timestamp
  ,      doc.doc_comment
  FROM documents         doc  
  ,    process_instances pin
  ,    processes         proc
  WHERE doc.pro_id = g_pro_id
  AND   pin.pro_id = g_pro_id -- double check
  AND   pin.proc_id = proc.id
  AND   pin.id = l_pin_id
  AND   pin.ctx_id     = doc.ctx_id
  AND   proc.ctx_table = doc.ctx_table
  ;
                    
-- uploaded docs for the project, all pins
CURSOR c_doc_all IS
  SELECT doc.id 
  ,      pin.id       pin_id 
  ,      proc.name    proc_name  
  ,      doc.filename
  ,      doc.doc_size
  ,      doc.timestamp
  ,      doc.doc_comment
  FROM documents doc
  ,    processes proc
  ,    process_instances pin  
  WHERE doc.pro_id = g_pro_id
  AND   doc.ctx_table = proc.ctx_table
  AND   doc.ctx_id    = pin.ctx_id 
  AND   pin.proc_id = proc.id    
  ;                    
 
-- attached documents for a specific pin
CURSOR c_doc_attached IS
  SELECT doc.id
  ,      doc.filename
  ,      doc.doc_size
  ,      dus.timestamp
  ,      doc.doc_comment
  ,      dus.usage_comment 
  FROM documents         doc 
  ,    document_usages   dus  
  ,    process_instances pin
  ,    processes         proc
  WHERE doc.pro_id = g_pro_id
  AND   pin.pro_id = g_pro_id -- double check
  AND   pin.proc_id = proc.id
  AND   pin.id = l_pin_id
  AND   pin.ctx_id     = dus.ctx_id
  AND   proc.ctx_table = dus.ctx_table 
  AND   dus.doc_id = doc.id
  ;
BEGIN 
 -- pin_id   
 l_pin_id := TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<pin_id>'),1,10));
 
 IF l_pin_id IS NULL THEN
    
   -- uploaded docs for the project, all pins
   FOR r_doc_all IN c_doc_all LOOP   
    l_count_doc_all := l_count_doc_all + 1;
    l_response_doc_all := l_response_doc_all || 
       pk_xml_api.create_element('file',
          pk_xml_api.create_element('doc_id',r_doc_all.id) ||     
          pk_xml_api.create_element('pin_id',r_doc_all.pin_id) ||  
          pk_xml_api.create_save_element('proc_name',r_doc_all.proc_name) ||                    
          pk_xml_api.create_save_element('filename',r_doc_all.filename) || 
          pk_xml_api.create_element('doc_size',r_doc_all.doc_size) ||
          pk_xml_api.create_save_element('doc_comment',r_doc_all.doc_comment) ||                     
          pk_xml_api.create_element('timestamp',to_char(r_doc_all.timestamp,'dd-mm-yyyy hh24:mi:ss')) ||  
          pk_xml_api.create_element('timestamp_since',APEX_UTIL.GET_SINCE_TSWLTZ(r_doc_all.timestamp))                   
                                );
   END LOOP;  
  
   l_response := pk_xml_api.create_element('all_uploaded_files',
                             pk_xml_api.create_element('count',l_count_doc_all) ||
                             l_response_doc_all
                                           );  
 ELSE
 
   -- uploaded docs for the project, all pins
   FOR r_doc_pin IN c_doc_pin LOOP   
    l_count_doc_pin := l_count_doc_pin + 1;
    l_response_doc_pin := l_response_doc_pin || 
       pk_xml_api.create_element('file',
          pk_xml_api.create_element('doc_id',r_doc_pin.id) ||      
          pk_xml_api.create_save_element('filename',r_doc_pin.filename) || 
          pk_xml_api.create_element('doc_size',r_doc_pin.doc_size) ||
          pk_xml_api.create_save_element('doc_comment',r_doc_pin.doc_comment)  ||            
          pk_xml_api.create_element('timestamp',to_char(r_doc_pin.timestamp,'dd-mm-yyyy hh24:mi:ss')) ||  
          pk_xml_api.create_element('timestamp_since',APEX_UTIL.GET_SINCE_TSWLTZ(r_doc_pin.timestamp))                   
                                );
   END LOOP;  
  
   l_response_doc_pin := pk_xml_api.create_element('uploaded_pin_files',
                             pk_xml_api.create_element('count',l_count_doc_pin) ||
                             l_response_doc_pin
                                                  );  
    
   -- uploaded docs for the project, all pins
   FOR r_doc_attached IN c_doc_attached LOOP   
    l_count_doc_attached := l_count_doc_attached + 1;
    l_response_doc_attached := l_response_doc_attached || 
       pk_xml_api.create_element('file',
          pk_xml_api.create_element('doc_id',r_doc_attached.id) ||      
          pk_xml_api.create_save_element('filename',r_doc_attached.filename) || 
          pk_xml_api.create_element('doc_size',r_doc_attached.doc_size) ||
          pk_xml_api.create_save_element('doc_comment',r_doc_attached.doc_comment)  ||    
          pk_xml_api.create_save_element('usage_comment',r_doc_attached.usage_comment)  ||                     
          pk_xml_api.create_element('timestamp_attached',to_char(r_doc_attached.timestamp,'dd-mm-yyyy hh24:mi:ss')) ||  
          pk_xml_api.create_element('timestamp_attached_since',APEX_UTIL.GET_SINCE_TSWLTZ(r_doc_attached.timestamp))                   
                                );
   END LOOP;  
  
   l_response_doc_attached :=  pk_xml_api.create_element('attached_pin_files',
                             pk_xml_api.create_element('count',l_count_doc_attached) ||
                             l_response_doc_attached
                                                        );  
    
   l_response :=   pk_xml_api.create_element('all_pin_files',  
                 l_response_doc_attached || l_response_doc_pin);
 END IF;
 
 RETURN l_response; 
    
END;
FUNCTION ADD_FILES
 RETURN VARCHAR2
 IS
-- Add files to a pin_id (internal via ctx_id/ctx_table)
 
-- to do: security, is user allowed to add these files
 
l_pin_id NUMBER; 
l_doc_id NUMBER;    
l_ctx_id NUMBER;
l_ctx_table     VARCHAR2(250); 
l_usage_comment VARCHAR2(4000);
i        NUMBER;
 
CURSOR c_ctx IS
  SELECT pin.ctx_id
  ,      proc.ctx_table
  FROM process_instances pin
  ,    processes         proc
  WHERE pin.proc_id = proc.id
  AND   pin.id = l_pin_id;
BEGIN
    
  l_pin_id := TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<pin_id>'),1,10));
  
  -- ctx info
  OPEN c_ctx;
  FETCH c_ctx INTO l_ctx_id
              ,    l_ctx_table;
  CLOSE c_ctx;
   
  -- Loop through docs to be attached
  i := 1;
  WHILE TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<doc_id>',i),1,10)) IS NOT NULL LOOP
     l_doc_id := TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<doc_id>',i),1,10));
     l_usage_comment := SUBSTR(pk_xml_api.get_tag_data(g_message,'<usage_comment>',i),1,4000);
 
     i:=i+1; 
     
     INSERT INTO document_usages
       ( id
       , use_id
       , doc_id
       , ctx_table
       , ctx_id
       , usage_comment ) VALUES
         ( seq_all.nextval
         , g_use_id
         , l_doc_id
         , l_ctx_table
         , l_ctx_id
         , l_usage_comment );
  END LOOP;
  
  RETURN pk_xml_api.create_element('result','Ok.');
      
END;
FUNCTION REMOVE_FILES
 RETURN VARCHAR2
 IS
-- Remove files from a pin_id (internal via ctx_id/ctx_table)
 
-- to do: security, is user allowed to remove these files
 
l_pin_id NUMBER; 
l_doc_id NUMBER;    
l_ctx_id NUMBER;
l_ctx_table VARCHAR2(250);
i        NUMBER;
 
CURSOR c_ctx IS
  SELECT pin.ctx_id
  ,      proc.ctx_table
  FROM process_instances pin
  ,    processes         proc
  WHERE pin.proc_id = proc.id
  AND   pin.id = l_pin_id;
BEGIN
    
  l_pin_id := TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<pin_id>'),1,10));
  
  -- ctx info
  OPEN c_ctx;
  FETCH c_ctx INTO l_ctx_id
              ,    l_ctx_table;
  CLOSE c_ctx;
   
  -- Loop through docs to be removed
  i := 1;
  WHILE TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<doc_id>',i),1,10)) IS NOT NULL LOOP
     l_doc_id := TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<doc_id>',i),1,10));
 
     i:=i+1; 
     
     DELETE FROM document_usages
     WHERE doc_id    = l_doc_id
     AND   ctx_table = l_ctx_table
     AND   ctx_id    = l_ctx_id;
  
     -- LATER: this shpuld be replaced by a different request from PYTHON, i.e. remove_file_from_doc
     UPDATE documents
     SET ctx_table = 'deleted_' || ctx_table
     WHERE id        = l_doc_id
     AND   ctx_table = l_ctx_table
     AND   ctx_id    = l_ctx_id;
 
  END LOOP;
  
  RETURN pk_xml_api.create_element('result','Ok.');
      
END;
FUNCTION GET_DOCUMENT_GROUP_LIST
 RETURN CLOB
 IS
-- Get a document_group list
 
-- to do: security Is a user allowed to see these documents      
-- limit now to pro_id only?
 
l_response              CLOB;  
l_response_doc_grp      CLOB;  
 
l_count_doc_grp         NUMBER := 0;
 
-- revision = all:
--  all document_groups in project
 
-- revision = highest:
--  only the highest revision for document_groups in project
 
l_rev_option            VARCHAR2(50);
 
-- all document_groups within the project
CURSOR c_doc_groups_all IS
  SELECT dgr.id
  ,      dgr.doc_number
  ,      dgr.revision_number
  ,      dgr.subject
  FROM document_groups   dgr  
  WHERE dgr.pro_id = g_pro_id
  ORDER BY dgr.doc_number       -- PIKET: volgorde
  ,        dgr.revision_number  -- PIKET: volgorde
  ;
 
-- only the highest revision for document_groups within the project
CURSOR c_doc_groups_high IS
  SELECT dgr.id
  ,      dgr.doc_number
  ,      dgr.revision_number
  ,      dgr.subject
  FROM document_groups   dgr  
  WHERE dgr.pro_id = g_pro_id
  AND dgr.revision_number = 
    (SELECT max(dgr1.revision_number) FROM document_groups dgr1
     WHERE dgr1.doc_number = dgr.doc_number
     AND dgr1.pro_id = dgr.pro_id)
  ;
BEGIN 
 
 -- rev_option   
 l_rev_option := lower(SUBSTR(pk_xml_api.get_tag_data(g_message,'<rev_option>'),1,10));
 
 IF l_rev_option = 'all' or l_rev_option = 'highest' THEN -- LATER: highest kan niet tegen doc_number NULL of niet uniek. Braga moet dit opvangen met foutmelding.
 
   -- all document_groups within the project
   FOR r_doc_groups_all IN c_doc_groups_all LOOP   
    l_count_doc_grp := l_count_doc_grp + 1;
    l_response_doc_grp := l_response_doc_grp || 
       pk_xml_api.create_element('document',
          pk_xml_api.create_element('dgr_id',r_doc_groups_all.id) ||     
          pk_xml_api.create_save_element('doc_number',r_doc_groups_all.doc_number) ||                    
          pk_xml_api.create_save_element('subject',r_doc_groups_all.subject) ||                    
          pk_xml_api.create_element('revision_number',r_doc_groups_all.revision_number)                   
                                );
   END LOOP;  
  
   l_response := pk_xml_api.create_element('document_list',
                             pk_xml_api.create_element('count',l_count_doc_grp) ||
                             l_response_doc_grp
                                           );  
 ELSE
 
   -- only the highest revision for document_groups within the project
   FOR r_doc_groups_high IN c_doc_groups_high LOOP   
    l_count_doc_grp := l_count_doc_grp + 1;
    l_response_doc_grp := l_response_doc_grp || 
       pk_xml_api.create_element('document',
          pk_xml_api.create_element('dgr_id',r_doc_groups_high.id) ||     
          pk_xml_api.create_save_element('doc_number',r_doc_groups_high.doc_number) ||                    
          pk_xml_api.create_save_element('subject',r_doc_groups_high.subject) ||                    
          pk_xml_api.create_element('revision_number',r_doc_groups_high.revision_number)                   
                                );
   END LOOP;  
  
   l_response := pk_xml_api.create_element('document_list',
                             pk_xml_api.create_element('count',l_count_doc_grp) ||
                             l_response_doc_grp
                                           );  
        
 END IF;
 
 RETURN l_response; 
    
END;
FUNCTION ADD_DOCUMENT_GROUPS
 RETURN VARCHAR2
 IS
-- Add document_groups to a pin_id (internal via ctx_id/ctx_table)
 
-- to do: security, is user allowed to add these document groups
 
l_pin_id NUMBER; 
l_dgr_id NUMBER;               
l_pse_id NUMBER;   
l_ctx_id NUMBER;
l_ctx_table     VARCHAR2(250); 
l_usage_comment VARCHAR2(4000);
i        NUMBER;
 
CURSOR c_ctx IS
  SELECT pin.ctx_id
  ,      proc.ctx_table
  FROM process_instances pin
  ,    processes         proc
  WHERE pin.proc_id = proc.id
  AND   pin.id = l_pin_id;
BEGIN
    
  l_pin_id := TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<pin_id>'),1,10));
  
  -- ctx info
  OPEN c_ctx;
  FETCH c_ctx INTO l_ctx_id
              ,    l_ctx_table;
  CLOSE c_ctx;
   
  -- Loop through doc_groups to be attached
  i := 1;
  WHILE TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<dgr_id>',i),1,10)) IS NOT NULL LOOP
     l_dgr_id := TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<dgr_id>',i),1,10));   
     l_pse_id := TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<pse_id>',i),1,10));     
     l_usage_comment := SUBSTR(pk_xml_api.get_tag_data(g_message,'<usage_comment>',i),1,4000);
 
     i:=i+1; 
     
     INSERT INTO document_group_usages
       ( id
       , use_id
       , dgr_id    
       , pse_id
       , ctx_table
       , ctx_id
       , usage_comment ) VALUES
         ( seq_all.nextval
         , g_use_id
         , l_dgr_id
         , l_pse_id
         , l_ctx_table
         , l_ctx_id
         , l_usage_comment );
  END LOOP;
  
  RETURN pk_xml_api.create_element('result','Ok.');
      
END;
FUNCTION REMOVE_DOCUMENT_GROUPS
 RETURN VARCHAR2
 IS
-- Remove document_groups from a pin_id (internal via ctx_id/ctx_table)
 
-- to do: security, is user allowed to remove these document groups
 
l_pin_id NUMBER; 
l_dgr_id NUMBER;    
l_ctx_id NUMBER;
l_ctx_table VARCHAR2(250);
i        NUMBER;
 
CURSOR c_ctx IS
  SELECT pin.ctx_id
  ,      proc.ctx_table
  FROM process_instances pin
  ,    processes         proc
  WHERE pin.proc_id = proc.id
  AND   pin.id = l_pin_id;
BEGIN
    
  l_pin_id := TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<pin_id>'),1,10));
  
  -- ctx info
  OPEN c_ctx;
  FETCH c_ctx INTO l_ctx_id
              ,    l_ctx_table;
  CLOSE c_ctx;
   
  -- Loop through document groups to be removed
  i := 1;
  WHILE TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<dgr_id>',i),1,10)) IS NOT NULL LOOP
     l_dgr_id := TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<dgr_id>',i),1,10));
 
     i:=i+1; 
     
     DELETE FROM document_group_usages
     WHERE dgr_id    = l_dgr_id
     AND   ctx_table = l_ctx_table
     AND   ctx_id    = l_ctx_id;
  
  END LOOP;
  
  RETURN pk_xml_api.create_element('result','Ok.');
      
END;
FUNCTION GET_ATTACHED_DOCUMENT_GROUPS
 RETURN CLOB
 IS
-- Get attached document groups
 
-- to do: security Is a user allowed to see these documents      
-- limit now to pro_id only?
 
l_response              CLOB;  
l_response_doc_attached CLOB;  
l_count_doc_attached    NUMBER := 0;   
 
l_pse          CLOB;
l_pses         CLOB;
l_dgu          CLOB;   
l_dgus         CLOB;
l_files        CLOB;
l_count_files  NUMBER := 0;
 
l_pin_id NUMBER;
 
 
-- attached files(documents) for a specific pin
CURSOR c_doc_attached IS
  SELECT doc.id
  ,      doc.filename
  ,      doc.doc_size
  ,      dus.timestamp
  ,      doc.doc_comment
  ,      dus.usage_comment
  ,      pse.name 
  FROM documents         doc 
  ,    document_usages   dus  
  ,    process_instances pin
  ,    processes         proc  
  ,    process_segments  pse  
  WHERE doc.pro_id = g_pro_id
  AND   pin.pro_id = g_pro_id -- double check
  AND   pin.proc_id = proc.id
  AND   pin.id = l_pin_id
  AND   pin.ctx_id     = dus.ctx_id
  AND   proc.ctx_table = dus.ctx_table 
  AND   dus.doc_id = doc.id
  AND   dus.pse_id = pse.id (+)
  ;    
 
-- attached document_group segments
CURSOR c_pse IS
  SELECT distinct pse.id
  ,      pse.name    
  FROM document_group_usages dgu
  ,    process_segments      pse 
  ,    process_instances     pin
  ,    processes             proc 
  WHERE dgu.pse_id = pse.id (+)
  AND   pin.pro_id = g_pro_id 
  AND   pin.proc_id = proc.id
  AND   pin.id = l_pin_id
  AND   pin.ctx_id     = dgu.ctx_id
  AND   proc.ctx_table = dgu.ctx_table ;
     
-- attached document_groups for a specific pin and segment
CURSOR c_dgu (b_pse_id IN NUMBER) IS
  SELECT dgr.id       dgr_id
  ,      dgu.timestamp
  ,      dgu.usage_comment     
  ,      dgr.dot_id
  ,      dgr.doc_number
  ,      dgr.revision_number
  ,      dgr.subject
  FROM document_groups         dgr
  ,    document_group_usages   dgu  
  ,    process_instances pin
  ,    processes         proc 
  WHERE dgr.pro_id = g_pro_id 
  AND   pin.pro_id = g_pro_id -- double check
  AND   pin.proc_id = proc.id
  AND   pin.id = l_pin_id
  AND   pin.ctx_id     = dgu.ctx_id
  AND   proc.ctx_table = dgu.ctx_table 
  AND   dgu.dgr_id = dgr.id  
  AND   (dgu.pse_id = b_pse_id OR b_pse_id IS NULL)
  ;   
 
-- files                    
CURSOR c_doc (b_dgr_id IN NUMBER) IS
  SELECT doc.id
  ,      doc.filename
  ,      doc.doc_size
  ,      doc.timestamp
  ,      doc.doc_comment
  FROM documents doc
  WHERE doc.dgr_id = b_dgr_id;
BEGIN 
 -- pin_id   
 l_pin_id := TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<pin_id>'),1,10));
    
   -- uploaded docs for the project, all pins
   FOR r_doc_attached IN c_doc_attached LOOP   
    l_count_doc_attached := l_count_doc_attached + 1;
    l_response_doc_attached := l_response_doc_attached || 
       pk_xml_api.create_element('file',
          pk_xml_api.create_element('doc_id',r_doc_attached.id) ||      
          pk_xml_api.create_save_element('filename',r_doc_attached.filename) || 
          pk_xml_api.create_element('doc_size',r_doc_attached.doc_size) ||
          pk_xml_api.create_save_element('doc_comment',r_doc_attached.doc_comment)  ||    
          pk_xml_api.create_save_element('usage_comment',r_doc_attached.usage_comment)  ||                     
          pk_xml_api.create_element('timestamp_attached',to_char(r_doc_attached.timestamp,'dd-mm-yyyy hh24:mi:ss')) ||  
          pk_xml_api.create_element('timestamp_attached_since',APEX_UTIL.GET_SINCE_TSWLTZ(r_doc_attached.timestamp))                   
                                );
   END LOOP;  
  
   l_response_doc_attached :=  pk_xml_api.create_element('file_usages',
                             pk_xml_api.create_element('count',l_count_doc_attached) ||
                             l_response_doc_attached  );  
 
-- Segments
FOR r_pse IN c_pse LOOP
 
  l_pse := pk_xml_api.create_element('segment_id',r_pse.id)  || 
           pk_xml_api.create_save_element('segment_name',r_pse.name);   
  
  l_dgus := NULL;
  
  -- document_group_usages for a segment
  FOR r_dgu IN c_dgu (b_pse_id => r_pse.id ) LOOP   
    
    l_dgu :=  pk_xml_api.create_element('dgr_id',r_dgu.dgr_id) ||     
              pk_xml_api.create_save_element('usage_comment',r_dgu.usage_comment)  || 
              pk_xml_api.create_element('dot_id',r_dgu.dot_id) ||
              pk_xml_api.create_element('doc_number',r_dgu.doc_number) ||
              pk_xml_api.create_save_element('revision_number',r_dgu.revision_number)  || 
              pk_xml_api.create_save_element('subject',r_dgu.subject); 
        
    -- uploaded docs for a document_group  
    l_files := NULL;
    l_count_files := 0;
    
    FOR r_doc IN c_doc(b_dgr_id => r_dgu.dgr_id) LOOP   
       l_count_files := l_count_files + 1;
       l_files := l_files || 
       pk_xml_api.create_element('file',
           pk_xml_api.create_element('doc_id',r_doc.id) ||      
           pk_xml_api.create_save_element('filename',r_doc.filename) || 
           pk_xml_api.create_element('doc_size',r_doc.doc_size) ||
           pk_xml_api.create_save_element('doc_comment',r_doc.doc_comment)  ||                     
           pk_xml_api.create_element('timestamp_attached',to_char(r_doc.timestamp,'dd-mm-yyyy hh24:mi:ss')) ||  
           pk_xml_api.create_element('timestamp_attached_since',APEX_UTIL.GET_SINCE_TSWLTZ(r_doc.timestamp))                   
                                 );
    END LOOP;  
   
    l_files :=  pk_xml_api.create_element('files',
                              pk_xml_api.create_element('count',l_count_files) ||
                              l_files );  
    -- Add dgu
    l_dgus := l_dgus || pk_xml_api.create_element('document_group',l_dgu || l_files);
               
  END LOOP;         
  l_dgus := pk_xml_api.create_element('document_group_usages',l_dgus);
  
  -- Add pse          
  l_pses := l_pses || pk_xml_api.create_element('segment', l_pse || l_dgus);
  
 END LOOP;
 
 l_pses := pk_xml_api.create_element('segments',l_pses);
 
 l_response := pk_xml_api.create_element('usages',  
                l_response_doc_attached || l_pses);
 
RETURN l_response; 
     
END;
FUNCTION LOGIN
 RETURN CLOB
 IS
-- Log in
-- Anonymous session will be connected to user
 
l_email    VARCHAR2(100); 
l_password VARCHAR2(100);
l_result   CLOB;
BEGIN
 
 -- Init
 g_module   := 'pk_api.login';
 g_location := '1';
 
 l_email    := SUBSTR(pk_xml_api.get_tag_data(g_message,'<email>'),1,100);
 l_password := SUBSTR(pk_xml_api.get_tag_data(g_message,'<password>'),1,100);
 
 -- Normale inlogpoging
 IF g_use_id IS NULL AND g_pro_id IS NULL AND g_session_string IS NOT NULL AND
    l_email IS NOT NULL AND l_password IS NOT NULL THEN
 
   --check username/password
   g_location := '2';
   g_use_id := pk_api.check_credentials(l_email, l_password);
 
   IF g_use_id IS NOT NULL THEN
 
      -- Update session with use_id
      -- inloggen
      g_location := '3';
      UPDATE web_sessions
      SET use_id = g_use_id
      WHERE session_string = g_session_string;
 
      COMMIT;
 
      -- Register  login
      g_location := '4';
      pk_api.use_log( p_type   => 'I' -- inloggen
                    , p_sit_id => g_sit_id
                    , p_use_id => g_use_id );
 
      -- Return user info
      g_location := '5';
      l_result := pk_api.get_user_info;
 
      RETURN l_result;
 
    -- Invalid credentials
    ELSE
       g_location := '6';
       RETURN pk_xml_api.create_element('error','Invalid credentials.');
    END IF;
 
  -- Invalid parameters (eg use_id is not null)
  ELSE
     g_location := '7';
     RETURN pk_xml_api.create_element('error','Invalid parameters.');
  END IF;
 
END;
FUNCTION CHECK_CREDENTIALS
 (P_EMAIL IN VARCHAR2
 ,P_PASSWORD IN VARCHAR2
 )
 RETURN NUMBER
 IS
-- Check user credentials (email and password) against user table    
l_use_id NUMBER;
BEGIN       
    
  -- Normal users 
  SELECT use.id 
  INTO l_use_id
  FROM users         use 
  WHERE UPPER(use.email) = UPPER(p_email)
  AND   use.password   = p_password
  AND   use.ind_active = 'Y';  
    
  RETURN l_use_id;
  
EXCEPTION WHEN OTHERS THEN
  -- too many rows or no data found 
  RETURN null;
    
END;
FUNCTION LOGOUT
 RETURN VARCHAR2
 IS
-- Logout
 
l_ip_address VARCHAR2(100);
l_host_name  VARCHAR2(250);
BEGIN
 
   -- Init
   g_module   := 'pk_api.logout';
   g_location := '1';
   
   l_ip_address := SUBSTR(pk_xml_api.get_tag_data(g_message,'<ip_address>'),1,100);
   l_host_name  := SUBSTR(pk_apex_security.get_host_name(l_ip_address),1,250);
  
   -- Register logout
      pk_api.use_log( p_type   => 'U' -- Logout
                    , p_sit_id => g_sit_id
                    , p_use_id => g_use_id );
 
   -- Delete session 
   g_location := '2';
   DELETE FROM web_sessions
   WHERE session_string = g_session_string;
 
   -- User, project, sessie null
   g_location := '3';
   g_use_id := NULL;
   g_pro_id := NULL;
   g_session_string := NULL;
 
   -- Nieuwe sessie
   g_location := '4';
   g_session_string := pk_api.generate_session;
   INSERT INTO web_sessions
       ( session_string
       , sit_id
       , ip_address
       , host_name ) VALUES
         ( g_session_string
         , g_sit_id
         , l_ip_address
         , l_host_name);
 
   COMMIT;
 
   -- Result
   RETURN pk_xml_api.create_element('result','Ok.');
 
END;
FUNCTION GET_USER_ACTIVITY
 RETURN CLOB
 IS
-- determine user activity for a certain project
 
l_response CLOB;
 
CURSOR c_uac IS
SELECT uac2.*
,      rownum nr
FROM
( SELECT uac.use_id
  ,      uac.use_name
  ,      uac.last_activity
  ,      uac.color
  ,      use.com_id
  ,      com.name com_name
  FROM user_activity uac
  ,    users         use
  ,    companies     com
  WHERE uac.pro_id = g_pro_id      
  AND   uac.use_id <> g_use_id
  AND   use.id = uac.use_id
  AND   com.id = use.com_id
  ORDER BY uac.color_order
  ,        uac.use_name ) uac2 ;
BEGIN
 
  FOR r_uac IN c_uac LOOP
    l_response := l_response || 
       pk_xml_api.create_element('user',
          pk_xml_api.create_element('nr',r_uac.nr) ||
          pk_xml_api.create_element('use_id',r_uac.use_id) ||      
          pk_xml_api.create_save_element('use_name',r_uac.use_name) ||
          pk_xml_api.create_element('com_id',r_uac.com_id) ||      
          pk_xml_api.create_save_element('com_name',r_uac.com_name) ||
          pk_xml_api.create_element('last_activity',r_uac.last_activity) ||  
          pk_xml_api.create_element('color',r_uac.color)
                                );
  END LOOP;    
  
  RETURN pk_xml_api.create_element('user_activity',l_response);  
 
END;
FUNCTION GET_USER_INFO
 RETURN CLOB
 IS
-- Return the user info
 
l_response CLOB;
 
CURSOR c_use IS
  SELECT use.name   use_name
  ,      use.email  email       
  ,      com.name   com_name
  ,      com.id     com_id
  FROM users     use
  ,    companies com
  WHERE use.id = g_use_id
  AND   use.com_id = com.id;
r_use c_use%ROWTYPE;
BEGIN
 
 -- Init
 g_module   := 'pk_api.get_user_info';
 g_location := '1';
    
  OPEN c_use;  
  FETCH c_use INTO r_use;
  CLOSE c_use;
  
  l_response := pk_xml_api.create_element('user',
                         pk_xml_api.create_save_element('name',r_use.use_name) ||
                         pk_xml_api.create_save_element('email',r_use.email) ||     
                         pk_xml_api.create_save_element('com_id',r_use.com_id) ||
                         pk_xml_api.create_save_element('company',r_use.com_name) 
                                          );    
  RETURN l_response;  
    
END;
FUNCTION GET_USER_PROJECTS
 RETURN CLOB
 IS
-- Return the user projects info   
-- order_nr for the most busy project
 
l_response CLOB;
 
-- project info
CURSOR c_pro IS
  SELECT rownum  order_nr
  ,      data.*
  FROM
  ( 
   SELECT  pk_wf_api.get_nr_of_all_tasks( p_pro_id => upa.pro_id )   all_tasks
   ,       pk_wf_api.get_nr_of_use_tasks( p_use_id => g_use_id
                                        , p_pro_id => upa.pro_id )   tasks   -- 1
   ,       pk_wf_api.get_nr_of_use_alerts( p_use_id => g_use_id
                                         , p_pro_id => upa.pro_id )  alerts  -- 2
   ,       pk_wf_api.get_nr_of_use_shared( p_use_id => g_use_id
                                         , p_pro_id => upa.pro_id )  shared  -- 3
   ,       pk_wf_api.get_nr_of_use_news( p_use_id => g_use_id
                                       , p_pro_id => upa.pro_id )    news    -- 4
   ,       upa.pro_id           pro_id
   FROM vw_use_pro_active upa
   WHERE upa.use_id = g_use_id
   AND   upa.ind_active = 'Y'
   ORDER BY 1
   ,        2
   ,        3
   ,        4
   ) data;
BEGIN              
 
 -- Init
 g_module   := 'pk_api.get_user_projects';
 g_location := '1';
 
  -- All projects for this user
  FOR r_pro IN c_pro LOOP
     
     l_response := l_response ||
                   pk_api_util.get_pro_details
                         ( p_pro_id => r_pro.pro_id,
                           p_data =>  pk_xml_api.create_element('total_tasks',r_pro.all_tasks) ||      
                                      pk_xml_api.create_element('tasks',r_pro.tasks) ||      
                                      pk_xml_api.create_element('alerts',r_pro.alerts) || 
                                      pk_xml_api.create_element('shared',r_pro.shared) || 
                                      pk_xml_api.create_element('news',r_pro.news) ||
                                      pk_xml_api.create_save_element('order_nr',r_pro.order_nr)
                          );   
  END LOOP; 
  
  RETURN pk_xml_api.create_element('projects',l_response);  
    
END;
FUNCTION GET_PROJECT_INFO
 RETURN CLOB
 IS
-- Get project info           
 
l_response CLOB;
l_tasks    NUMBER;
l_alerts   NUMBER;
l_shared   NUMBER;
l_news     NUMBER;   
 
l_agreements VARCHAR2(10000);    
l_users      VARCHAR2(10000); 
l_company    VARCHAR2(20000); 
l_wbs        VARCHAR2(5000); 
l_proc       VARCHAR2(5000);
 
-- companies
CURSOR c_com IS      
  SELECT prc.id    prc_id
  ,      com.id    id
  ,      com.name  name    
  ,      com.type  type
  FROM companies         com
  ,    project_companies prc
  WHERE prc.com_id = com.id
  AND   prc.pro_id = g_pro_id
  AND   prc.date_from <= trunc(sysdate)
  AND   NVL(prc.date_to,trunc(sysdate)) >= trunc(sysdate)  
  AND   com.id NOT IN (SELECT use.com_id         -- don't return your own company
                       FROM users use
                       WHERE use.id = g_use_id)
  ORDER BY com.name;                
r_com c_com%ROWTYPE;
 
-- agreements
CURSOR c_agr (b_prc_id NUMBER) IS
  SELECT agr.id           id
  ,      agr.po_nr        po_nr
  ,      agr.description  description   
  FROM agreements  agr
  WHERE agr.prc_id = b_prc_id
  ORDER BY agr.po_nr;
 
-- users
CURSOR c_use (b_com_id NUMBER) IS
  SELECT use.id        id
  ,      use.name      name  
  FROM users use
  WHERE use.com_id = b_com_id
  AND   use.ind_active = 'Y'
  ORDER BY use.name;
 
-- wbs numbers
CURSOR c_wbs IS
  SELECT wnu.id          id
  ,      wnu.nr          nr
  ,      wnu.description description              
  FROM wbs_numbers wnu
  WHERE wnu.pro_id = g_pro_id;
BEGIN              
 
 -- Init
 g_module   := 'pk_api.get_project_info';
 g_location := '1';
 
 -- project info
 l_tasks := pk_wf_api.get_nr_of_use_tasks( p_use_id=> g_use_id
                                         , p_pro_id=> g_pro_id);
 l_alerts := pk_wf_api.get_nr_of_use_alerts( p_use_id => g_use_id
                                         , p_pro_id => g_pro_id);  
 l_shared := pk_wf_api.get_nr_of_use_shared( p_use_id => g_use_id
                                         , p_pro_id => g_pro_id);         
 l_news   := pk_wf_api.get_nr_of_use_news( p_use_id => g_use_id
                                       , p_pro_id => g_pro_id); 
 
 -- companies and agreements info
 FOR r_com IN c_com LOOP
   -- companies
   l_company := pk_xml_api.create_element('com_id',r_com.id)      ||
                pk_xml_api.create_save_element('name',r_com.name) ||
                pk_xml_api.create_element('type',r_com.type);
   -- Agreements
   l_agreements := NULL;
   FOR r_agr IN c_agr( b_prc_id => r_com.prc_id) LOOP
      l_agreements := l_agreements || pk_xml_api.create_element('agreement',
                                          pk_xml_api.create_element('agr_id',r_agr.id)  ||
                                          pk_xml_api.create_element('po_nr',r_agr.po_nr)||
                                          pk_xml_api.create_save_element('description',r_agr.description)
                                                               );
   END LOOP;     
   l_company := l_company || pk_xml_api.create_element('agreements',l_agreements); 
   
   
  -- Users
   l_users := NULL;
   FOR r_use IN c_use( b_com_id => r_com.id) LOOP
      l_users := l_users || pk_xml_api.create_element('user',
                              pk_xml_api.create_element('use_id',r_use.id)  ||
                              pk_xml_api.create_element('name',r_use.name)
                                                      );
   END LOOP;     
   l_company := l_company || pk_xml_api.create_element('users',l_users); 
        
        
   -- Add company
   l_response := l_response || pk_xml_api.create_element('company',l_company);             
                  
 END LOOP; 
 
 -- all companies
 l_response := pk_xml_api.create_element('companies',l_response);
 
 -- wbs
 FOR r_wbs IN c_wbs LOOP
    l_wbs := l_wbs || pk_xml_api.create_element('wbs_number',
                                 pk_xml_api.create_element('wnu_id',r_wbs.id)  ||
                                 pk_xml_api.create_element('nr',r_wbs.nr)||
                                 pk_xml_api.create_save_element('description',r_wbs.description)
                                                );
 END LOOP;     
 l_wbs := pk_xml_api.create_element('wbs_numbers',l_wbs); 
 
 -- processes 
 l_proc := pk_wf_api.get_use_all_process( p_use_id=> g_use_id
                                          , p_pro_id=> g_pro_id ); 
 
 -- response
 l_response := pk_api_util.get_pro_details        -- combine project, companies, wbs
                         ( p_pro_id => g_pro_id,
                           p_data => pk_xml_api.create_element('tasks',l_tasks) ||      
                                     pk_xml_api.create_element('alerts',l_alerts) || 
                                     pk_xml_api.create_element('shared',l_shared) || 
                                     pk_xml_api.create_element('news',l_news) ||
                                     l_response || 
                                     l_wbs ||
                                     l_proc
                          );
 
  RETURN l_response;  
    
END;
FUNCTION GET_PROCESS_START_INFO
 RETURN CLOB
 IS
-- Get process start info
-- to do: cursor c_proc is geen loop ...
 
 
l_proc_id            NUMBER;
l_ctx_table          VARCHAR2(100);
 
l_response           CLOB;
l_companies          CLOB;
l_target_companies   CLOB;
l_departments        CLOB;
l_rec_depts          CLOB;
l_issue_depts        CLOB;
 
l_agreements         VARCHAR2(10000);
l_users              VARCHAR2(10000);
l_company            VARCHAR2(20000);
l_target_company     VARCHAR2(20000);
l_rec_dept           VARCHAR2(20000);
l_issue_dept         VARCHAR2(20000);
l_department         VARCHAR2(20000);
 
l_wbs                VARCHAR2(5000);
l_proc               VARCHAR2(1000);
 
l_doc_types          CLOB;
l_doc_type           VARCHAR2(20000);  
 
l_proc_segments       CLOB;
l_proc_segment        VARCHAR2(20000);  
 
l_pac_managers        VARCHAR2(10000);
 
-- Segments
CURSOR c_pse IS
  SELECT pse.id
  ,      pse.name
  ,      pse.abbreviation
  FROM process_segments pse
  WHERE pse.proc_id = l_proc_id
  order by pse.show_seq;
  
-- process
CURSOR c_proc IS
  SELECT proc.name
  ,      proc.ctx_table
  FROM processes proc
  WHERE proc.id = l_proc_id;
 
-- document types
CURSOR c_dot IS
  SELECT dot.id
  ,      dot.name
  FROM document_types dot;
 
-- companies
CURSOR c_com IS
  SELECT prc.id    prc_id
  ,      com.id    id
  ,      com.name  name
  FROM companies         com
  ,    project_companies prc
  WHERE prc.com_id = com.id
  AND   prc.pro_id = g_pro_id
  AND   prc.date_from <= trunc(sysdate)
  AND   NVL(prc.date_to,trunc(sysdate)) >= trunc(sysdate)
  AND   com.id NOT IN (SELECT use.com_id         -- don't return your own company
                       FROM users use
                       WHERE use.id = g_use_id)
  AND   com.type = 'E'   -- companies
  ORDER BY com.name;
r_com c_com%ROWTYPE;
 
-- departments
CURSOR c_dept IS
  SELECT prc.id    prc_id
  ,      com.id    id
  ,      com.name  name
  FROM companies         com
  ,    project_companies prc
  WHERE prc.com_id = com.id
  AND   prc.pro_id = g_pro_id
  AND   prc.date_from <= trunc(sysdate)
  AND   NVL(prc.date_to,trunc(sysdate)) >= trunc(sysdate)
  AND   com.id NOT IN (SELECT use.com_id         -- don't return your own department
                       FROM users use
                       WHERE use.id = g_use_id)
  AND   com.type = 'I'   -- departments
  ORDER BY com.name;
r_dept c_dept%ROWTYPE;
 
-- agreements
CURSOR c_agr (b_prc_id NUMBER) IS
  SELECT agr.id           id
  ,      agr.po_nr        po_nr
  ,      agr.description  description
  FROM agreements  agr
  WHERE agr.prc_id = b_prc_id
  ORDER BY agr.po_nr;
 
-- users
CURSOR c_use (b_com_id NUMBER) IS
SELECT DISTINCT use.id        id
,      use.name      name
FROM users use
,    user_projects usp
,    user_pro_roles upr
,    roles rol
WHERE use.com_id = b_com_id
AND   use.ind_active = 'Y'
AND   usp.use_id = use.id
AND   usp.pro_id = g_pro_id
AND   upr.usp_id = usp.id
AND   rol.id = upr.rol_id
AND   ((rol.name = 'Answerer' AND l_ctx_table = 'information_requests')-- LATER: moet uiteindelijk uit setup tabel komen
      or l_ctx_table <> 'information_requests')
ORDER BY use.name;
 
-- pac_managers
CURSOR c_pmg IS
SELECT DISTINCT use.id        id
,      use.name      name
FROM users use
,    user_projects usp
,    user_pro_roles upr
,    roles rol
WHERE use.ind_active = 'Y'
AND   usp.use_id = use.id
AND   usp.pro_id = g_pro_id
AND   upr.usp_id = usp.id
AND   rol.id = upr.rol_id
AND   l_ctx_table = 'packages' -- LATER: moet waarschijnlijk specifieker
ORDER BY use.name;
 
-- wbs numbers
CURSOR c_wbs IS
  SELECT wnu.id          id
  ,      wnu.nr          nr
  ,      wnu.description description
  FROM wbs_numbers wnu
  WHERE wnu.pro_id = g_pro_id
  ORDER BY wnu.nr;
BEGIN
 
 -- Init
 g_module   := 'pk_api.get_process_start_info';
 g_location := '1';
 
 -- Process data
 l_proc_id     := TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<proc_id>'),1,10));
 
   FOR r_proc IN c_proc LOOP
      l_response := pk_xml_api.create_element('proc_id',l_proc_id)  ||
                    pk_xml_api.create_save_element('proc_name',r_proc.name);
   l_ctx_table := r_proc.ctx_table;
   END LOOP;
 
 -- Document Types
 
 IF l_ctx_table NOT IN ('eis') THEN
 FOR r_dot IN c_dot LOOP
   l_doc_type := pk_xml_api.create_element('dot_id',r_dot.id)      ||
                 pk_xml_api.create_save_element('doc_type_desc',r_dot.name);
   l_doc_types := l_doc_types || pk_xml_api.create_element('document_type',l_doc_type);
 END LOOP;
 l_doc_types := pk_xml_api.create_element('document_types',l_doc_types);
 l_response := l_response || l_doc_types;
 END IF;
 
 -- Segments
 FOR r_pse IN c_pse LOOP
   l_proc_segment := pk_xml_api.create_element('pse_id',r_pse.id)      ||
                     pk_xml_api.create_save_element('name',r_pse.name) ||
                     pk_xml_api.create_save_element('abbreviation',r_pse.abbreviation);
   l_proc_segments := l_proc_segments || pk_xml_api.create_element('proc_segment',l_proc_segment);    
 END LOOP;   
 l_proc_segments := pk_xml_api.create_element('proc_segments',l_proc_segments);
 l_response := l_response || l_proc_segments;
 
 
IF l_ctx_table IN ('ects') THEN
 -- receiving departments and users info
 FOR r_dept IN c_dept LOOP
 
     -- receiving departments
   l_rec_dept := pk_xml_api.create_element('dept_id',r_dept.id)      ||
                pk_xml_api.create_save_element('name',r_dept.name);
 
  -- Users
   l_users := NULL;
   FOR r_use IN c_use( b_com_id => r_dept.id) LOOP
      l_users := l_users || pk_xml_api.create_element('user',
                              pk_xml_api.create_element('use_id',r_use.id)  ||
                              pk_xml_api.create_element('name',r_use.name)
                                                      );
   END LOOP;
   l_rec_dept := l_rec_dept || pk_xml_api.create_element('users',l_users);
 
   -- Add department
   l_rec_depts := l_rec_depts || pk_xml_api.create_element('receiving_department',l_rec_dept);
 END LOOP;
 
 -- all receiving departments
 l_rec_depts := pk_xml_api.create_element('receiving_departments',l_rec_depts);
 l_response := l_response || l_rec_depts;
 END IF;
 
 
IF l_ctx_table IN ('ects') THEN
 -- issuing departments and users info
 FOR r_dept IN c_dept LOOP
 
     -- issuing departments
   l_issue_dept := pk_xml_api.create_element('dept_id',r_dept.id)      ||
                pk_xml_api.create_save_element('name',r_dept.name);
 
  -- Users
   l_users := NULL;
   FOR r_use IN c_use( b_com_id => r_dept.id) LOOP
      l_users := l_users || pk_xml_api.create_element('user',
                              pk_xml_api.create_element('use_id',r_use.id)  ||
                              pk_xml_api.create_element('name',r_use.name)
                                                      );
   END LOOP;
   l_issue_dept := l_issue_dept || pk_xml_api.create_element('users',l_users);
 
   -- Add department
   l_issue_depts := l_issue_depts || pk_xml_api.create_element('issuing_department',l_issue_dept);
 END LOOP;
 
 -- all issuing departments
 l_issue_depts := pk_xml_api.create_element('issuing_departments',l_issue_depts);
 l_response := l_response || l_issue_depts;
 END IF;
 
   
IF l_ctx_table IN ('information_requests','document_approvals','eis') THEN
 -- companies and agreements info
 FOR r_com IN c_com LOOP
   -- companies
   l_company := pk_xml_api.create_element('com_id',r_com.id)      ||
                pk_xml_api.create_save_element('name',r_com.name);
   -- Agreements
   l_agreements := NULL;
   FOR r_agr IN c_agr( b_prc_id => r_com.prc_id) LOOP
      l_agreements := l_agreements || pk_xml_api.create_element('agreement',
                                          pk_xml_api.create_element('agr_id',r_agr.id)  ||
                                          pk_xml_api.create_element('po_nr',r_agr.po_nr)||
                                          pk_xml_api.create_save_element('description',r_agr.description)
                                                               );
   END LOOP;
   l_company := l_company || pk_xml_api.create_element('agreements',l_agreements); 
 
   -- Add company
   l_companies := l_companies || pk_xml_api.create_element('company',l_company);
 END LOOP;
 
 -- all companies
 l_companies := pk_xml_api.create_element('companies',l_companies);
 l_response := l_response || l_companies;
 END IF;
 
 
 IF l_ctx_table IN ('ects') THEN
 -- target_companies and agreements info
 FOR r_com IN c_com LOOP
   -- target_companies
   l_target_company := pk_xml_api.create_element('target_com_id',r_com.id)      ||
                pk_xml_api.create_save_element('name',r_com.name);
   -- Agreements
   l_agreements := NULL;
   FOR r_agr IN c_agr( b_prc_id => r_com.prc_id) LOOP
      l_agreements := l_agreements || pk_xml_api.create_element('agreement',
                                          pk_xml_api.create_element('agr_id',r_agr.id)  ||
                                          pk_xml_api.create_element('po_nr',r_agr.po_nr)||
                                          pk_xml_api.create_save_element('description',r_agr.description)
                                                               );
   END LOOP;
   l_target_company := l_target_company || pk_xml_api.create_element('agreements',l_agreements); 
   -- Add company
   l_target_companies := l_target_companies || pk_xml_api.create_element('target_company',l_target_company);
 
 END LOOP;
 
 -- all target companies
 l_target_companies := pk_xml_api.create_element('target_companies',l_target_companies);
 l_response := l_response || l_target_companies;
END IF;
 
IF l_ctx_table IN ('information_requests','document_approvals','eis') THEN
 -- departments and users info
 FOR r_dept IN c_dept LOOP
 
     -- departments
   l_department := pk_xml_api.create_element('dept_id',r_dept.id)      ||
                pk_xml_api.create_save_element('name',r_dept.name);
 
  -- Users
   l_users := NULL;
   FOR r_use IN c_use( b_com_id => r_dept.id) LOOP
      l_users := l_users || pk_xml_api.create_element('user',
                              pk_xml_api.create_element('use_id',r_use.id)  ||
                              pk_xml_api.create_element('name',r_use.name)
                                                      );
   END LOOP;
   l_department := l_department || pk_xml_api.create_element('users',l_users);
 
   -- Add department
   l_departments := l_departments || pk_xml_api.create_element('department',l_department);
 END LOOP;
 
 -- all departments
 l_departments := pk_xml_api.create_element('departments',l_departments);
 l_response := l_response || l_departments;
 END IF;
 
 
 IF l_ctx_table IN ('packages') THEN
  -- issuing package managers info
 
   l_pac_managers := NULL;
   FOR r_pmg IN c_pmg LOOP
      l_pac_managers := l_pac_managers || pk_xml_api.create_element('pac_manager',
                               pk_xml_api.create_element('use_id',r_pmg.id)  ||
                               pk_xml_api.create_element('name',r_pmg.name)
                                                                   );
   END LOOP;
   
   l_pac_managers := pk_xml_api.create_element('pac_managers',l_pac_managers);
   l_response := l_response || l_pac_managers;
 
 END IF;
 
 
 -- wbs
 FOR r_wbs IN c_wbs LOOP
    l_wbs := l_wbs || pk_xml_api.create_element('wbs_number',
                                 pk_xml_api.create_element('wnu_id',r_wbs.id)  ||
                                 pk_xml_api.create_element('nr',r_wbs.nr)||
                                 pk_xml_api.create_save_element('description',r_wbs.description)
                                                );
 END LOOP;
 l_wbs := pk_xml_api.create_element('wbs_numbers',l_wbs);
 
 
 -- response
  l_response := pk_xml_api.create_element('process',l_response ||l_wbs);
 
  RETURN l_response;
 
END;
FUNCTION START_PROCESS
 RETURN CLOB
 IS
-- Start a process
 
-- For now the SI/IR/DA/ECT process is implemented, should be more generic !!!!
 
l_id           NUMBER;
l_proc_id      NUMBER; 
l_nr           NUMBER;
l_pin_id       NUMBER;
l_subject      VARCHAR2(250);
l_start_date   DATE;
l_end_date     DATE;  
l_reply_before DATE;
l_description  VARCHAR2(10000);
l_com_id       NUMBER;      
l_dest_use_id  NUMBER;
l_wnu_id       NUMBER;
l_agr_id       NUMBER;
l_com_type     VARCHAR2(1);
l_dot_id       NUMBER;  
l_doc_nr       VARCHAR2(50); 
l_revision_number  NUMBER; 
l_revision_comment VARCHAR2(4000);  
l_rec_com_id     NUMBER;
l_acc_use_id     NUMBER;
l_issue_com_id   NUMBER;
l_use_ect_id     NUMBER;
l_target_date    DATE;
l_target_com_id  NUMBER;
l_pack_number    VARCHAR2(50);
l_pack_use_id    NUMBER;    
 
l_pack_wbs       APEX_APPLICATION_GLOBAL.VC_ARR2;
 
l_wbs_list       APEX_APPLICATION_GLOBAL.VC_ARR2;
 
i                NUMBER;
 
CURSOR c_proc IS
  SELECT proc.ctx_table
  FROM processes proc
  WHERE proc.id = l_proc_id;
l_ctx_table processes.ctx_table%TYPE;
 
CURSOR c_pin IS
  SELECT pin.id
  FROM process_instances pin   
  WHERE pin.ctx_id = l_id;            
 
CURSOR c_com IS
  SELECT com.type
  FROM companies com
  WHERE com.id = l_com_id;
 
l_response VARCHAR2(1000);
BEGIN
 
 -- Init
 g_module   := 'pk_api.start_process';
 g_location := '1';
 
 -- Process data   
 l_proc_id     := TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<proc_id>'),1,10));
 l_subject     := SUBSTR(pk_xml_api.get_tag_data(g_message,'<subject>'),1,250);
 l_start_date  := TO_DATE(SUBSTR(pk_xml_api.get_tag_data(g_message,'<start_date>'),1,10),'dd-mm-yyyy');
 l_end_date    := TO_DATE(SUBSTR(pk_xml_api.get_tag_data(g_message,'<to_date>'),1,10),'dd-mm-yyyy');
 l_reply_before:= TO_DATE(SUBSTR(pk_xml_api.get_tag_data(g_message,'<reply_before>'),1,10),'dd-mm-yyyy');       -- for IR 
 l_description := SUBSTR(pk_xml_api.get_tag_data(g_message,'<description>'),1,10000);
 l_com_id      := TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<com_id>'),1,10)); 
 l_dest_use_id := TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<dest_use_id>'),1,10));
 l_wnu_id      := TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<wnu_id>'),1,10));
 l_agr_id      := TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<agr_id>'),1,10));     
 l_dot_id           := TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<dot_id>'),1,10));  
 l_doc_nr           := SUBSTR(pk_xml_api.get_tag_data(g_message,'<doc_nr>'),1,50);  
 l_revision_number  := TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<revision_number>'),1,10));  
 l_revision_comment := SUBSTR(pk_xml_api.get_tag_data(g_message,'<revision_comment>'),1,4000);  
 l_rec_com_id       := TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<rec_com_id>'),1,10)); 
 l_acc_use_id       := TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<acc_use_id>'),1,10));
 l_issue_com_id     := TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<issue_com_id>'),1,10)); 
 l_use_ect_id       := TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<use_ect_id>'),1,10));
 l_target_date      := TO_DATE(SUBSTR(pk_xml_api.get_tag_data(g_message,'<target_date>'),1,10),'dd-mm-yyyy');
 l_target_com_id    := TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<target_com_id>'),1,10)); 
 l_pack_number      := SUBSTR(pk_xml_api.get_tag_data(g_message,'<package_number>'),1,50);
 l_pack_use_id      := TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<pack_use_id>'),1,10)); 
 
 -- fill the WBS array for Packages (temporary)
 i := 1;
 WHILE TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<pack_wnu_id>',i),1,10)) IS NOT NULL LOOP
    l_pack_wbs(i) := TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<pack_wnu_id>',i),1,10));
    i:=i+1;
 END LOOP;
 
  -- fill the WBS array for Packages, ECTS and EI
  i := 1;
  WHILE TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<wnu_id>',i),1,10)) IS NOT NULL LOOP
     l_wbs_list(i) := TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<wnu_id>',i),1,10));
     i:=i+1;
  END LOOP;
 
 IF l_proc_id IS NULL OR 
    l_subject IS NULL OR 
    g_pro_id IS NULL THEN 
   RETURN pk_xml_api.create_element('error','Invalid parameters.');
 END IF;
    
 -- proc type
 OPEN c_proc;
 FETCH c_proc INTO l_ctx_table;
 CLOSE c_proc;  
 
 -- company type
 OPEN c_com;
 FETCH c_com INTO l_com_type;
 CLOSE c_com;  
 
 -- Check process
 IF lower(l_ctx_table) NOT IN ('site_instructions','information_requests','document_approvals','ects','packages','eis') THEN   
   RETURN pk_xml_api.create_element('error','Invalid process.');
 END IF;   
 
 
 -- Check parameters
 IF NOT(
        ( lower(l_ctx_table) = 'site_instructions' AND    
          l_com_id IS NOT NULL AND 
          l_agr_id IS NOT NULL )
         OR 
         ( lower(l_ctx_table) = 'information_requests' AND 
           l_com_type = 'I' AND     -- internal IR
           l_com_id      IS NOT NULL AND
           l_dest_use_id IS NOT NULL )
         OR
         ( lower(l_ctx_table) = 'information_requests' AND  
           l_com_type = 'E' AND     -- external IR
           l_com_id IS NOT NULL AND
--           l_wnu_id IS NOT NULL AND
           l_agr_id IS NOT NULL )     
         OR
         ( lower(l_ctx_table) = 'document_approvals' AND   
           l_dot_id  IS NOT NULL AND   
           l_subject IS NOT NULL AND
           l_doc_nr  IS NOT NULL AND
           l_revision_number IS NOT NULL )           
         OR
         ( lower(l_ctx_table) = 'ects' AND   
           l_subject IS NOT NULL)    
         OR
         ( lower(l_ctx_table) = 'packages' AND   
           l_subject IS NOT NULL)                       
         OR
         ( lower(l_ctx_table) = 'eis' AND   
           l_subject IS NOT NULL)    
       ) THEN
   RETURN pk_xml_api.create_element('error','Invalid parameters for this process.');
 END IF;
 
 -- SI
 IF lower(l_ctx_table) = 'site_instructions' THEN
   
   -- SI number 
   l_nr := pk_si.get_next_si_nr(p_pro_id => g_pro_id);
                   
   -- create SI
   l_id := seq_all.nextval;
   INSERT INTO site_instructions
     ( id
     , pro_id
     , com_id
     , agr_id
     , wnu_id 
     , subject
     , description
     , si_nr
     , required_start_date
     , indicated_end_date ) VALUES
     ( l_id
     , g_pro_id
     , l_com_id
     , l_agr_id
     , l_wnu_id
     , l_subject  
     , l_description
     , l_nr
     , l_start_date
     , l_end_date );
 
                          
 ELSIF lower(l_ctx_table) = 'information_requests' THEN
   
   -- IR number 
   l_nr := pk_ir.get_next_ir_nr(p_pro_id => g_pro_id);
                   
   -- create IR
   l_id := seq_all.nextval;
   INSERT INTO information_requests
     ( id
     , pro_id
     , com_id  
     , use_id
     , agr_id
--     , wnu_id 
     , subject
     , description 
     , reply_before
     , ir_nr ) VALUES
     ( l_id
     , g_pro_id
     , l_com_id 
     , l_dest_use_id
     , l_agr_id
--     , l_wnu_id
     , l_subject  
     , l_description
     , l_reply_before
     , l_nr );
 
   IF l_wbs_list.count >= 1 THEN
     FOR i IN 1 .. l_wbs_list.count LOOP
     -- Add WBS
        INSERT INTO ir_wbs_numbers
           ( irq_id
           , wnu_id) VALUES
           ( l_id
           , l_wbs_list(i));
     END LOOP;
   END IF;
    
 ELSIF lower(l_ctx_table) = 'document_approvals' THEN
 
   -- DA number 
   l_nr := pk_da.get_next_da_nr(p_pro_id => g_pro_id);
                   
   -- create DA
   l_id := seq_all.nextval;
   INSERT INTO document_approvals
     ( id
     , pro_id
     , dot_id  
     , subject
     , doc_number
     , revision_number
     , revision_comment
     , da_nr ) VALUES
     ( l_id
     , g_pro_id
     , l_dot_id 
     , l_subject
     , l_doc_nr  
     , l_revision_number
     , l_revision_comment
     , l_nr );
 
 ELSIF lower(l_ctx_table) = 'ects' THEN
 
   -- ECT number 
   l_nr := pk_ect.get_next_ect_nr(p_pro_id => g_pro_id);
                   
   -- create ECT
   l_id := seq_all.nextval;
   INSERT INTO ects
     ( id
     , pro_id
     , rec_com_id
     , acc_use_id
     , issue_com_id
     , use_ect_id
     , subject
     , target_date
     , description
     , target_com_id
     , agr_id
--     , wnu_id
     , ect_nr ) VALUES
     ( l_id
     , g_pro_id
     , l_rec_com_id
     , l_acc_use_id
     , l_issue_com_id
     , l_use_ect_id
     , l_subject
     , l_target_date
     , l_description
     , l_target_com_id  
     , l_agr_id
--     , l_wnu_id
     , l_nr );
 
   IF l_wbs_list.count >= 1 THEN
     FOR i IN 1 .. l_wbs_list.count LOOP
     -- Add WBS
        INSERT INTO ect_wbs_numbers
           ( ect_id
           , wnu_id) VALUES
           ( l_id
           , l_wbs_list(i));
     END LOOP;
   END IF;
 
 ELSIF lower(l_ctx_table) = 'packages' THEN
 
   -- PAC number 
   l_nr := pk_pac.get_next_pac_nr(p_pro_id => g_pro_id);
                   
   -- create PAC
   l_id := seq_all.nextval;
   INSERT INTO packages
     ( id
     , pro_id
     , subject
     , pack_number
     , pack_use_id
     , pac_nr ) VALUES
     ( l_id
     , g_pro_id
     , l_subject
     , l_pack_number
     , l_pack_use_id
     , l_nr );
 
   IF l_wbs_list.count >= 1 THEN
     FOR i IN 1 .. l_wbs_list.count LOOP
     -- Add WBS
        INSERT INTO package_wbs_numbers
           ( pac_id
           , wnu_id) VALUES
           ( l_id
           , l_wbs_list(i));
     END LOOP;
   END IF;
 
   -- TEMPORARY SOLUTION till Braga changed the tags or changed the design
 
   IF l_pack_wbs.count >= 1 THEN
     FOR i IN 1 .. l_pack_wbs.count LOOP
     -- Add WBS
        INSERT INTO package_wbs_numbers
           ( pac_id
           , wnu_id) VALUES
           ( l_id
           , l_pack_wbs(i));
     END LOOP;
   END IF;
 
 ELSIF lower(l_ctx_table) = 'eis' THEN
 
   -- EI number 
   l_nr := pk_ei.get_next_ei_nr(p_pro_id => g_pro_id);
                   
   -- create EI
   l_id := seq_all.nextval;
   INSERT INTO eis
     ( id
     , pro_id
     , rec_com_id
     , acc_use_id
     , agr_id
     , subject
     , description
     , ei_nr ) VALUES
     ( l_id
     , g_pro_id
     , l_rec_com_id
     , l_acc_use_id
     , l_agr_id
     , l_subject
     , l_description
     , l_nr );
 
   IF l_wbs_list.count >= 1 THEN
     FOR i IN 1 .. l_wbs_list.count LOOP
     -- Add WBS
        INSERT INTO ei_wbs_numbers
           ( eis_id
           , wnu_id) VALUES
           ( l_id
           , l_wbs_list(i));
     END LOOP;
   END IF;
 
END IF;
 
 
 -- create process and first task
 l_response := 
   pk_wf_api.start_process( p_ctx_id => l_id 
                          , p_use_id => g_use_id
                          , p_pro_id => g_pro_id
                          , p_proc_id => l_proc_id );     
 
 
 -- Determine created pin_id
 OPEN c_pin;
 FETCH c_pin INTO l_pin_id;
 CLOSE c_pin;
 
 RETURN NVL( l_response        
           , pk_xml_api.create_element('process',
                    pk_xml_api.create_element('nr',pk_wf_api.get_ctx_nr(p_pin_id=> l_pin_id)) ||  
                    pk_xml_api.create_element('pin_id',l_pin_id)
                                       )
            );
END;
FUNCTION GET_USER_PROJECT_TASKS
 RETURN CLOB
 IS
-- Get all open user tasks for this project
 
l_response CLOB;
l_pin_id NUMBER;
l_pac_id NUMBER;
 
-- open tasks  
CURSOR c_vuct IS
  SELECT vuct.tin_id      tin_id
  ,      vuct.type        type
  ,      tin.date_started date_started
  FROM vw_use_current_tasks vuct
  ,    task_instances       tin
  WHERE (vuct.use_id = g_use_id or NOT l_pac_id IS NULL)
  AND   vuct.pro_id = g_pro_id      
  AND   vuct.tin_id = tin.id  
  AND   vuct.pin_id = NVL(l_pin_id,vuct.pin_id) -- optional pin_id
  AND   (l_pac_id IS NULL OR vuct.ctx_id IN
     (SELECT ctx.id 
      FROM
       (SELECT ect_id id
        ,      wnu_id 
        FROM ect_wbs_numbers
        UNION
        SELECT irq_id id
        ,      wnu_id 
        FROM ir_wbs_numbers
        UNION
        SELECT eis_id id
        ,      wnu_id 
        FROM ei_wbs_numbers
       ) ctx
       WHERE ctx.wnu_id IN
        (SELECT wbs.wnu_id
         FROM package_wbs_numbers wbs
         WHERE wbs.pac_id = l_pac_id)))
  ORDER BY tin.date_started;
BEGIN
 
 -- Init
 g_module   := 'pk_api.get_user_project_tasks';
 g_location := '1';
 
 -- optional pin_id for returning only the user task for this process
 l_pin_id  := TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<pin_id>'),1,10));
 
-- optional pac_id for returning only tasks within a specific package
 l_pac_id      := TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<pac_id>'),1,10)); 
 
 FOR r_vuct IN c_vuct LOOP
    l_response := l_response ||
       pk_wf_api.get_task_info
          ( p_tin_id => r_vuct.tin_id
          , p_data =>  pk_xml_api.create_element('tin_id',r_vuct.tin_id) || 
                       pk_xml_api.create_element('type',r_vuct.type)
          );
 END LOOP; 
 
 RETURN pk_xml_api.create_element('tasks',l_response);
 
END;
FUNCTION GET_USER_PROJECT_ALERTS
 RETURN CLOB
 IS
-- Get all user alerts for this project
 
-- Extra PIKET (2015-04-06): selectie aangepast
 
 l_response CLOB;
 l_pac_id   NUMBER;
 
-- alerts
CURSOR c_vuct IS
  SELECT A.id tin_id
  ,      'Direct' type
  ,      A.date_started date_started
  FROM TASK_INSTANCES A
  ,    PROCESS_INSTANCES P
  WHERE P.ID = A.PIN_ID
  AND P.PRO_ID = g_pro_id
  AND NOT A.DATE_FINISHED IS NULL
  AND EXISTS
   (SELECT '*' 
    FROM PIN_PTA_ALERT_USERS B
    WHERE B.PIN_ID = A.PIN_ID
    AND B.USE_ID = g_use_id
    AND B.PTA_ID = A.PTA_ID
    AND B.IND_ACTIVE = 'Y')    
  AND NOT EXISTS
    (SELECT '*' 
     FROM dismissed_tasks dit
     WHERE dit.use_id = g_use_id
     AND   dit.tin_id = A.id)    
  AND   (l_pac_id IS NULL OR p.ctx_id IN
     (SELECT ctx.id 
      FROM
       (SELECT ect_id id
        ,      wnu_id 
        FROM ect_wbs_numbers
        UNION
        SELECT irq_id id
        ,      wnu_id 
        FROM ir_wbs_numbers
        UNION
        SELECT eis_id id
        ,      wnu_id 
        FROM ei_wbs_numbers
       ) ctx
       WHERE ctx.wnu_id IN
        (SELECT wbs.wnu_id
         FROM package_wbs_numbers wbs
         WHERE wbs.pac_id = l_pac_id)))
ORDER BY A.date_started;
BEGIN
 
 -- Init
 g_module   := 'pk_api.get_user_project_alerts';
 g_location := '1';
 
-- optional pac_id for returning only tasks within a specific package
 l_pac_id      := TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<pac_id>'),1,10)); 
 
 FOR r_vuct IN c_vuct LOOP
    l_response := l_response ||
       pk_wf_api.get_task_info
          ( p_tin_id => r_vuct.tin_id
          , p_data => pk_xml_api.create_element('type',r_vuct.type)
          );
 END LOOP; 
 
 RETURN pk_xml_api.create_element('tasks',l_response);
 
END;
FUNCTION GET_USER_PROJECT_SHARED
 RETURN CLOB
 IS
-- Get all user shared for this project
 
-- Extra PIKET (2015-04-06): selectie aangepast
    
  l_response CLOB;
  l_pac_id NUMBER;
 
-- shared
CURSOR c_vuct IS
  SELECT A.id tin_id
  ,      'Direct' type
  ,      A.date_started date_started
  FROM TASK_INSTANCES A
  ,    PROCESS_INSTANCES P
    WHERE P.ID = A.PIN_ID
    AND P.PRO_ID = g_pro_id
  AND NOT A.DATE_FINISHED IS NULL
  AND (EXISTS
   (SELECT '*' 
    FROM TIN_SHARE_USERS B
    WHERE B.TIN_ID = A.ID
    AND B.USE_ID = g_use_id
    AND B.IND_ACTIVE = 'Y')
  OR EXISTS
   (SELECT '*' 
    FROM PIN_SHARE_USERS B
    WHERE B.PIN_ID = A.PIN_ID
    AND B.USE_ID = g_use_id
    AND B.IND_ACTIVE = 'Y'))  
  AND NOT EXISTS
    (SELECT '*' 
     FROM dismissed_tasks dit
     WHERE dit.use_id = g_use_id
     AND   dit.tin_id = A.id)       
   AND   (l_pac_id IS NULL OR p.ctx_id IN
     (SELECT ctx.id FROM
       (SELECT ect_id id
        ,      wnu_id 
        FROM ect_wbs_numbers
        UNION
        SELECT irq_id id
        ,      wnu_id 
        FROM ir_wbs_numbers
        UNION
        SELECT eis_id id
        ,      wnu_id 
        FROM ei_wbs_numbers
       ) ctx
      WHERE ctx.wnu_id IN
        (SELECT wbs.wnu_id
         FROM package_wbs_numbers wbs
         WHERE wbs.pac_id = l_pac_id)))
ORDER BY A.date_started;
BEGIN
 
 -- Init
 g_module   := 'pk_api.get_user_project_shared';
 g_location := '1';
 
-- optional pac_id for returning only tasks within a specific package
 l_pac_id      := TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<pac_id>'),1,10)); 
 
 FOR r_vuct IN c_vuct LOOP
    l_response := l_response ||
       pk_wf_api.get_task_info
          ( p_tin_id => r_vuct.tin_id
          , p_data => pk_xml_api.create_element('type',r_vuct.type)
          );
 END LOOP; 
 
 RETURN pk_xml_api.create_element('tasks',l_response);
 
END;
FUNCTION GET_USER_PROJECT_NEWS
 RETURN CLOB
 IS
-- Get all user news for this project
 
-- to do: limited aantal, het zijn er veel
-- to do: bijhouden welke zijn gezien: intersectie tussen tin en use
       -- over welke processen is dit? uitvoeren: pro_roles, zien:?
       
-- Extra PIKET (2015-04-06): selectie aangepast
-- Aanpassing PIKET(2015-04-13): Laatste 25 ipv eerste 25 --> DESC toegevoed aan sorteer sleutel EN date_finished ipv started
 
   l_response CLOB;
   l_pac_id NUMBER;
 
-- news
CURSOR c_vuct IS
  SELECT * 
  FROM (SELECT A.id tin_id
  ,      'Direct' type
  ,      A.date_started date_started
        FROM TASK_INSTANCES A
        ,    PROCESS_INSTANCES P
        WHERE P.ID = A.PIN_ID
        AND P.PRO_ID = g_pro_id
        AND NOT A.DATE_FINISHED IS NULL
        AND NOT (EXISTS
   (SELECT '*' FROM TIN_SHARE_USERS B
    WHERE B.TIN_ID = A.ID
    AND B.USE_ID = g_use_id
    AND B.IND_ACTIVE = 'Y')
  OR EXISTS
   (SELECT '*' FROM PIN_SHARE_USERS B
    WHERE B.PIN_ID = A.PIN_ID
    AND B.USE_ID = g_use_id
       AND B.IND_ACTIVE = 'Y'))
  AND NOT EXISTS
   (SELECT '*' 
    FROM PIN_PTA_ALERT_USERS B
    WHERE B.PIN_ID = A.PIN_ID
    AND B.USE_ID = g_use_id
    AND B.PTA_ID = A.PTA_ID
    AND B.IND_ACTIVE = 'Y')
  AND NOT EXISTS
    (SELECT '*' 
     FROM dismissed_tasks dit
     WHERE dit.use_id = g_use_id
     AND   dit.tin_id = A.id)
      AND   (l_pac_id IS NULL OR p.ctx_id IN
     (SELECT ctx.id 
      FROM
       (SELECT ect_id id
        ,      wnu_id 
        FROM ect_wbs_numbers
        UNION
        SELECT irq_id id
        ,      wnu_id 
        FROM ir_wbs_numbers
        UNION
        SELECT eis_id id
        ,      wnu_id 
        FROM ei_wbs_numbers
       ) ctx
      WHERE ctx.wnu_id IN
        (SELECT wbs.wnu_id
         FROM package_wbs_numbers wbs
         WHERE wbs.pac_id = l_pac_id
        )
     )
     )
      AND EXISTS
        (SELECT 1
         FROM vw_use_pro_proc_active vupp
         WHERE vupp.use_id  = g_use_id
         AND   vupp.pro_id  = g_pro_id
         AND   vupp.proc_id = P.proc_id
         AND   vupp.ind_active = 'Y')
      ORDER BY A.date_finished DESC)
 WHERE rownum <= 25;
BEGIN
 
 -- Init
 g_module   := 'pk_api.get_user_project_news';
 g_location := '1';
 
-- optional pac_id for returning only tasks within a specific package
 l_pac_id      := TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<pac_id>'),1,10)); 
 
 FOR r_vuct IN c_vuct LOOP
    l_response := l_response ||
       pk_wf_api.get_task_info
          ( p_tin_id => r_vuct.tin_id
          , p_data => pk_xml_api.create_element('type',r_vuct.type)
          );
 END LOOP; 
 
 RETURN pk_xml_api.create_element('tasks',l_response);
 
END;
FUNCTION GET_USER_PROJECT_TRACKING
 RETURN CLOB
 IS
-- Get all user tracking for this project
 
  l_response CLOB;
  l_pac_id NUMBER;
 
-- tracking  
CURSOR c_vuct IS
  SELECT vuct.tin_id      tin_id
  ,      vuct.type        type
  ,      tin.date_started date_started
  FROM vw_use_current_tasks vuct
  ,    task_instances       tin
  WHERE vuct.use_id = g_use_id
  AND   vuct.pro_id = g_pro_id      
  AND   vuct.tin_id = tin.id
  AND   (l_pac_id IS NULL OR vuct.ctx_id IN
     (SELECT ctx.id 
      FROM
       (SELECT ect_id id
        ,      wnu_id 
        FROM ect_wbs_numbers
        UNION
        SELECT irq_id id
        ,      wnu_id 
        FROM ir_wbs_numbers
        UNION
        SELECT eis_id id
        ,      wnu_id 
        FROM ei_wbs_numbers
       ) ctx
      WHERE ctx.wnu_id IN
        (SELECT wbs.wnu_id
         FROM package_wbs_numbers wbs
         WHERE wbs.pac_id = l_pac_id)))
  ORDER BY tin.date_started;
BEGIN
 
 -- Init
 g_module   := 'pk_api.get_user_project_tracking';
 g_location := '1';
 
-- optional pac_id for returning only tasks within a specific package
 l_pac_id      := TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<pac_id>'),1,10)); 
 
 FOR r_vuct IN c_vuct LOOP
    l_response := l_response ||
       pk_wf_api.get_task_info
          ( p_tin_id => r_vuct.tin_id
          , p_data => pk_xml_api.create_element('type',r_vuct.type)
          );
 END LOOP; 
 
 RETURN pk_xml_api.create_element('tasks',l_response);
 
END;
FUNCTION GET_TIMELINE
 RETURN CLOB
 IS
-- Get the timeline for this process
 
l_response CLOB;
l_pin_id   NUMBER;
 
-- all tasks for a process 
CURSOR c_vat IS  
  SELECT rownum  order_nr
  ,      data.*
  FROM
  ( 
  SELECT vat.tin_id    tin_id
  FROM vw_all_tasks    vat
  ,    task_instances  tin
  WHERE vat.pro_id = g_pro_id 
  AND   vat.pin_id = l_pin_id     
  AND   vat.tin_id = tin.id
  ORDER BY tin.id               -- in a netwerk the ORDER is misleading, sequential is ok.
  ) data;
BEGIN
 
 -- Init
 g_module   := 'pk_api.get_timeline';
 g_location := '1';
 
l_pin_id := TO_NUMBER(pk_xml_api.get_tag_data(g_message,'<pin_id>'));
 
 
 FOR r_vat IN c_vat LOOP
    l_response := l_response ||
       pk_wf_api.get_task_info
          ( p_tin_id => r_vat.tin_id
          , p_data => pk_xml_api.create_element('order_nr',r_vat.order_nr)
          );
 END LOOP; 
 
 RETURN pk_xml_api.create_element('timeline_tasks',l_response);
 
END;
FUNCTION GET_TASK_INFO
 RETURN CLOB
 IS
-- Return the task instance data      
 
l_response CLOB;
l_tin_id   NUMBER;
BEGIN
  
 -- Init
 g_module   := 'pk_api.get_task_info';
 g_location := '1';  
 
 -- data
 l_tin_id := TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<tin_id>'),1,10));  
 l_response := pk_wf_api.get_task_info( p_tin_id => l_tin_id );
 
 RETURN l_response;
 
END;
FUNCTION GET_PROCESS_INFO
 RETURN CLOB
 IS
-- Return the process instance data      
 
-- to do: meer generiek, nu SI and IR
 
l_response CLOB;
l_pin_id   NUMBER;
l_table    VARCHAR2(100);    
 
-- process info
CURSOR c_ctx IS
  SELECT proc.ctx_table tab
  FROM process_instances pin
  ,    processes         proc
  WHERE pin.id = l_pin_id
  AND   pin.proc_id = proc.id;
BEGIN
  
 -- Init
 g_module   := 'pk_api.get_process_info';
 g_location := '1';  
 
 -- data
 l_pin_id := TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<pin_id>'),1,10));  
 
 -- get ctx info
 OPEN c_ctx;
 FETCH c_ctx INTO l_table;
 CLOSE c_ctx;
                      
 IF UPPER(l_table) = 'SITE_INSTRUCTIONS' THEN
    l_response := pk_wf_api.get_process_info_SI(p_pin_id => l_pin_id);
 ELSIF UPPER(l_table) = 'INFORMATION_REQUESTS' THEN
    l_response := pk_wf_api.get_process_info_IR(p_pin_id => l_pin_id); 
 ELSIF UPPER(l_table) = 'DOCUMENT_APPROVALS' THEN
    l_response := pk_wf_api.get_process_info_DA(p_pin_id => l_pin_id);      
 ELSIF UPPER(l_table) = 'ECTS' THEN
    l_response := pk_wf_api.get_process_info_ECT(p_pin_id => l_pin_id); 
 ELSIF UPPER(l_table) = 'PACKAGES' THEN
    l_response := pk_wf_api.get_process_info_PAC(p_pin_id => l_pin_id);               
 ELSIF UPPER(l_table) = 'EIS' THEN
    l_response := pk_wf_api.get_process_info_EI(p_pin_id => l_pin_id);               
 ELSE
    l_response := 'No process found';
 END IF;
 
 RETURN l_response;
 
END;
FUNCTION EXECUTE_TASK
 RETURN VARCHAR2
 IS
-- Execute a task 
 
l_error        VARCHAR2(4000); 
l_tin_id       NUMBER;
l_next_pta     APEX_APPLICATION_GLOBAL.VC_ARR2;
l_next_use     APEX_APPLICATION_GLOBAL.VC_ARR2;   
l_task_comment VARCHAR2(4000);
i              NUMBER;
BEGIN    
    
-- task instance to execute
l_tin_id := TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<tin_id>'),1,10));        
l_task_comment := SUBSTR(pk_xml_api.get_tag_data(g_message,'<task_comment>'),1,4000); 
 
-- fill the array
i := 1;
WHILE TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<next_pta_id>',i),1,10)) IS NOT NULL LOOP
   l_next_pta(i) := TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<next_pta_id>',i),1,10));
   l_next_use(i) := TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<next_use_id>',i),1,10)); 
   i:=i+1;
END LOOP;   
 
-- Execute task
pk_wf_api.execute_task( p_tin_id => l_tin_id
                      , p_use_id => g_use_id
                      , p_next_pta => l_next_pta
                      , p_next_use => l_next_use 
                      , p_task_comment  => l_task_comment);
                     
RETURN pk_xml_api.create_element('result','Ok.'); 
         
EXCEPTION WHEN OTHERS THEN    
    l_error := SQLERRM;
    pk_log.log_message( p_module  => 'pk_api.execute_task'
                      , p_message => 'Unexpected error, error:'||substr(l_error,1,3000) || ' use_id:'||g_use_id ||' tin_id:'||l_tin_id );  
    raise_application_error( -20001, 'Unexpected error when executing this task.' );
END;
FUNCTION UPDATE_PROCESS
 RETURN CLOB
 IS
-- Update a process
-- Later the updatable/mandatory fields must be dynamically determined per process task   
-- to do: meer generiek, nu SI and IR
 
l_response CLOB;
l_pin_id   NUMBER;
l_table    VARCHAR2(100);    
l_info     VARCHAR2(1000);
l_id       NUMBER;
l_com_type VARCHAR2(1);
 
-- process data
l_subject          VARCHAR2(250);
l_description      VARCHAR2(10000);
l_com_id           NUMBER;      
l_wnu_id           NUMBER;
l_agr_id           NUMBER;
 
-- SI specific
l_start_date       DATE;
l_end_date         DATE;
 
-- IR specific
l_reply_before     DATE;
l_dest_use_id      NUMBER;
l_ir_response      VARCHAR2(10000);
 
-- DA specific
l_dot_id           NUMBER;  
l_doc_nr           VARCHAR2(50); 
l_revision_number  NUMBER; 
l_revision_comment VARCHAR2(4000);  
 
-- ECT specific
l_rec_com_id       NUMBER;
l_acc_use_id       NUMBER;
l_issue_com_id     NUMBER;
l_use_ect_id       NUMBER;
l_target_date      DATE;
l_target_com_id    NUMBER;
 
-- PAC specific
l_pack_number      VARCHAR2(50);
l_pack_use_id      NUMBER;
l_pack_wbs         APEX_APPLICATION_GLOBAL.VC_ARR2;
 
-- WBS list
l_wbs_list         APEX_APPLICATION_GLOBAL.VC_ARR2;
 
i                  NUMBER;
 
-- process info
CURSOR c_ctx IS
  SELECT proc.ctx_table tab
  ,      pin.ctx_id     ctx_id
  FROM process_instances pin
  ,    processes         proc
  WHERE pin.id = l_pin_id
  AND   pin.proc_id = proc.id;
 
CURSOR c_com IS
  SELECT com.type
  FROM companies com
  WHERE com.id = l_com_id;
BEGIN
  
 -- Init
 g_module   := 'pk_api.update_process';
 g_location := '1';  
 
 -- data
 l_pin_id := TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<pin_id>'),1,10));  
   
 -- Process data   
 l_subject          := SUBSTR(pk_xml_api.get_tag_data(g_message,'<subject>'),1,250);
 l_description      := SUBSTR(pk_xml_api.get_tag_data(g_message,'<description>'),1,10000);
 l_com_id           := TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<com_id>'),1,10)); 
 l_wnu_id           := TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<wnu_id>'),1,10));
 l_agr_id           := TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<agr_id>'),1,10));  
 
-- Process data SI specific
 l_start_date       := TO_DATE(SUBSTR(pk_xml_api.get_tag_data(g_message,'<start_date>'),1,10),'dd-mm-yyyy');         -- for SI
 l_end_date         := TO_DATE(SUBSTR(pk_xml_api.get_tag_data(g_message,'<to_date>'),1,10),'dd-mm-yyyy');            -- for SI
 
-- Process data IR specific
 l_reply_before     := TO_DATE(SUBSTR(pk_xml_api.get_tag_data(g_message,'<reply_before>'),1,10),'dd-mm-yyyy');       -- for IR
 l_dest_use_id      := TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<dest_use_id>'),1,10));
 l_ir_response      := SUBSTR(pk_xml_api.get_tag_data(g_message,'<response>'),1,10000); 
 
 -- Process data DA specific
 l_dot_id           := TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<dot_id>'),1,10));  
 l_doc_nr           := SUBSTR(pk_xml_api.get_tag_data(g_message,'<doc_nr>'),1,50);  
 l_revision_number  := TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<revision_number>'),1,10));  
 l_revision_comment := SUBSTR(pk_xml_api.get_tag_data(g_message,'<revision_comment>'),1,4000);  
 
 -- Process data ECT specific
 l_rec_com_id       := TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<rec_com_id>'),1,10));
 l_acc_use_id       := TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<acc_use_id>'),1,10));
 l_issue_com_id     := TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<issue_com_id>'),1,10));
 l_use_ect_id       := TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<use_ect_id>'),1,10));
 l_target_date      := TO_DATE(SUBSTR(pk_xml_api.get_tag_data(g_message,'<target_date>'),1,10),'dd-mm-yyyy');
 l_target_com_id    := TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<target_com_id>'),1,10));
 
 -- Process data PAC specific
 l_pack_number      := SUBSTR(pk_xml_api.get_tag_data(g_message,'<package_number>'),1,50);
 l_pack_use_id      := TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<pack_use_id>'),1,10));
 
 -- fill the WBS array for Packages
 i := 1;
 WHILE TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<pack_wnu_id>',i),1,10)) IS NOT NULL LOOP
    l_pack_wbs(i) := TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<pack_wnu_id>',i),1,10));
    i:=i+1;
 END LOOP;
 
 -- fill the generic WBS list
 i := 1;
 WHILE TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<wnu_id>',i),1,10)) IS NOT NULL LOOP
    l_wbs_list(i) := TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<wnu_id>',i),1,10));
    i:=i+1;
 END LOOP;
 
 -- get ctx info
 OPEN c_ctx;
 FETCH c_ctx INTO l_table
             ,    l_id;
 CLOSE c_ctx; 
 
 -- company type
 OPEN c_com;
 FETCH c_com INTO l_com_type;
 CLOSE c_com;  
 
 
BEGIN 
    
   IF g_pro_id IS NULL THEN
     raise_application_error(-20101, 'Project may not be empty.');    
   END IF;  
    
   IF UPPER(l_table) = 'SITE_INSTRUCTIONS' THEN 
      
      -- checks
      --  none
      UPDATE site_instructions
      SET subject = l_subject 
      ,   required_start_date = l_start_date
      ,   indicated_end_date = l_end_date
      ,   description = l_description
      ,   com_id = l_com_id
      ,   wnu_id = l_wnu_id
      ,   agr_id = l_agr_id 
      WHERE id = l_id;
      
      l_response := pk_wf_api.get_process_info_SI(p_pin_id => l_pin_id);
      
   ELSIF UPPER(l_table) = 'INFORMATION_REQUESTS' THEN
      
      -- checks
      IF NOT( 
         ( l_com_type = 'I' AND     -- internal IR
           l_com_id IS NOT NULL AND
           l_dest_use_id IS NOT NULL )
           OR
         ( l_com_type = 'E' AND     -- external IR
           l_com_id IS NOT NULL AND
--           l_wnu_id IS NOT NULL AND
           l_agr_id IS NOT NULL )  
           OR
           l_reply_before IS NOT NULL
           ) THEN 
        raise_application_error(-20101, 'Internal / External company error');    
      END IF;     
      
      UPDATE information_requests
      SET subject = l_subject 
      ,   description = l_description
      ,   com_id = l_com_id 
      ,   use_id = l_dest_use_id
--      ,   wnu_id = l_wnu_id
      ,   agr_id = l_agr_id   
      ,   reply_before = l_reply_before
      ,   response = l_ir_response      
      WHERE id = l_id;     
      l_response := pk_wf_api.get_process_info_IR(p_pin_id => l_pin_id);
 
     -- Delete old wbs-s
     DELETE from ir_wbs_numbers
     WHERE irq_id = l_id;
    
     IF l_wbs_list.count >= 1 THEN
        FOR i IN 1 .. l_wbs_list.count LOOP
        -- Add WBS
           INSERT INTO ir_wbs_numbers
             ( irq_id
             , wnu_id) VALUES
             ( l_id
             , l_wbs_list(i));
        END LOOP;
     END IF;
 
   ELSIF UPPER(l_table) = 'DOCUMENT_APPROVALS' THEN 
      
      -- checks
      --  none
      UPDATE document_approvals
      SET subject = l_subject 
      ,   dot_id  = l_dot_id
      ,   doc_number = l_doc_nr
      ,   revision_number  = l_revision_number
      ,   revision_comment = l_revision_comment    
      WHERE id = l_id;
 
      l_response := pk_wf_api.get_process_info_DA(p_pin_id => l_pin_id);
 
   ELSIF UPPER(l_table) = 'ECTS' THEN 
      
      -- checks
      --  none
      UPDATE ects
      SET subject = l_subject 
      ,   description = l_description
      ,   rec_com_id = l_rec_com_id
      ,   acc_use_id = l_acc_use_id
      ,   issue_com_id = l_issue_com_id
      ,   use_ect_id = l_use_ect_id
      ,   target_date  = l_target_date
      ,   target_com_id = l_target_com_id
      ,   agr_id = l_agr_id 
--      ,   wnu_id = l_wnu_id
      WHERE id = l_id;
 
     -- Delete old wbs-s
     DELETE from ect_wbs_numbers
     WHERE ect_id = l_id;
    
     IF l_wbs_list.count >= 1 THEN
        FOR i IN 1 .. l_wbs_list.count LOOP
           -- Add WBS
           INSERT INTO ect_wbs_numbers
            ( ect_id
            , wnu_id) VALUES
            ( l_id
          , l_wbs_list(i));
        END LOOP;
     END IF;      
 
      l_response := pk_wf_api.get_process_info_ECT(p_pin_id => l_pin_id);
     
   ELSIF UPPER(l_table) = 'PACKAGES' THEN 
      
      -- checks
      --  none
      UPDATE packages
      SET subject = l_subject 
      ,   pack_number = l_pack_number
      ,   pack_use_id = l_pack_use_id
      WHERE id = l_id;
      
      -- Delete old wbs-s
      DELETE from package_wbs_numbers
      WHERE pac_id = l_id;
      
      IF l_pack_wbs.count >= 1 THEN
         FOR i IN 1 .. l_pack_wbs.count LOOP
            -- Add WBS
            INSERT INTO package_wbs_numbers
             ( pac_id
             , wnu_id) VALUES
             ( l_id
             , l_pack_wbs(i));
         END LOOP;
      END IF;      
      
      l_response := pk_wf_api.get_process_info_PAC(p_pin_id => l_pin_id);
      
   ELSIF UPPER(l_table) = 'EIS' THEN 
      
     -- checks
     --  none
     UPDATE eis
     SET subject = l_subject 
     ,   description = l_description
     ,   rec_com_id = l_rec_com_id
     ,   acc_use_id = l_acc_use_id
     ,   agr_id = l_agr_id 
     WHERE id = l_id;
      
     -- Delete old wbs-s
     DELETE from ei_wbs_numbers
     WHERE eis_id = l_id;
    
     IF l_wbs_list.count >= 1 THEN
        FOR i IN 1 .. l_wbs_list.count LOOP
           -- Add WBS
           INSERT INTO ei_wbs_numbers
            ( eis_id
            , wnu_id) VALUES
            ( l_id
          , l_wbs_list(i));
        END LOOP;
     END IF;      
  
     l_response := pk_wf_api.get_process_info_EI(p_pin_id => l_pin_id);
 
   ELSE
      l_response := 'No process found';
   END IF;
 EXCEPTION WHEN OTHERS THEN  
   l_response := 'Invalid data or not all mandatory fields are filled';
 END; 
  
 RETURN l_response;
 
END;
FUNCTION GET_NEXT_TASK_INFO
 RETURN CLOB
 IS
-- Determine the next tasks, given a tin_id
-- only return info if this user may see it (incorporate g_use_id in the query)
--!!! see pk_workflow.generate_next_task_query for to do's, now only simple ANDs !!!
 
l_tin_id NUMBER;
l_response CLOB;
BEGIN  
 
  l_tin_id   := TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<tin_id>'),1,10));        
  l_response := pk_wf_api.get_next_task_info( p_tin_id => l_tin_id
                                            , p_use_id => g_use_id 
                                            , p_pro_id => g_pro_id );
  
  RETURN l_response;
 
END;
FUNCTION GET_USER_PROJECT_PROCESSES
 RETURN CLOB
 IS
-- Get all processes instances in scope of a user/project
 
l_response      CLOB;
l_process       CLOB;
l_columns       CLOB;
l_proc_id       NUMBER;
l_ctx_table     VARCHAR2(250);
l_wnu_list      VARCHAR2(10000);
 
l_files         CLOB;
l_date_finished DATE;
 
-- processes 
CURSOR c_proc IS  
  SELECT proc.pin_id   
  ,      proc.proc_id
  ,      proc.abbr
  ,      proc.ctx_table
  ,      pk_wf_util.get_formatted_wf_nr (p_nr => proc.nr
                                       , p_wf_abbr => proc.abbr
                                       , p_length => 3)          wf_nr
  ,      proc.subject
  ,      proc.use_id_start                       initiator
  ,      ius.name                                init_name
  ,      NVL(pta.description,'n.a. (finished)')  next_task   
  ,      tin.use_id_execute                      next_user
  ,      nus.name                                next_name
  ,      tin.date_started
  ,      DECODE(tin.id
               ,null,'Closed'
               ,'Open') state 
  ,      proc.id    ctx_id
  FROM
  (SELECT pin.id pin_id
         , pin.proc_id
         , 'IR' abbr
         , ir.ir_nr nr
         , ir.subject
         , pin.use_id use_id_start
         , pin.pro_id
         , proc.ctx_table
         , ir.id
   FROM process_instances pin
   ,    information_requests ir
   ,    processes proc
   WHERE ir.id = pin.ctx_id
   AND pin.proc_id = proc.id
   AND proc.ctx_table = 'information_requests'
   UNION ALL
   SELECT pin.id
   ,      pin.proc_id
   ,      'SI'
   ,      si.si_nr
   ,      si.subject
   ,      pin.use_id
   ,      pin.pro_id
   ,      proc.ctx_table
   ,      si.id
   FROM process_instances pin
   , site_instructions si
   , processes proc
   WHERE si.id = pin.ctx_id
   AND pin.proc_id = proc.id
   AND proc.ctx_table = 'site_instructions'    
   UNION ALL
   SELECT pin.id
   ,      pin.proc_id
   ,      'DA'
   ,      da.da_nr
   ,      da.subject
   ,      pin.use_id
   ,      pin.pro_id
   ,      proc.ctx_table
   ,      da.id
   FROM process_instances pin
   , document_approvals da
   , processes proc
   WHERE da.id = pin.ctx_id
   AND pin.proc_id = proc.id
   AND proc.ctx_table = 'document_approvals' 
   UNION ALL
   SELECT pin.id
   ,      pin.proc_id
   ,      'ECT'
   ,      ect.ect_nr
   ,      ect.subject
   ,      pin.use_id
   ,      pin.pro_id
   ,      proc.ctx_table
   ,      ect.id
   FROM process_instances pin
   ,    ects ect
   ,    processes proc
   WHERE ect.id = pin.ctx_id
   AND pin.proc_id = proc.id
   AND proc.ctx_table = 'ects'     
   UNION ALL
   SELECT pin.id
   ,      pin.proc_id
   ,      'PAC'
   ,      pac.pac_nr
   ,      pac.subject
   ,      pin.use_id
   ,      pin.pro_id
   ,      proc.ctx_table
   ,      pac.id
   FROM process_instances pin
   ,    packages pac
   ,    processes proc
   WHERE pac.id = pin.ctx_id
   AND pin.proc_id = proc.id
   AND proc.ctx_table = 'packages'      
   UNION ALL
   SELECT pin.id
   ,      pin.proc_id
   ,      'EI'
   ,      eis.ei_nr
   ,      eis.subject
   ,      pin.use_id
   ,      pin.pro_id
   ,      proc.ctx_table
   ,      eis.id
   FROM process_instances pin
   ,    eis eis
   ,    processes proc
   WHERE eis.id = pin.ctx_id
   AND pin.proc_id = proc.id
   AND proc.ctx_table = 'eis'      
   ) proc
   ,  task_instances  tin
   ,  process_tasks   pta
   ,  users           ius
   ,  users           nus
  WHERE (proc.proc_id = l_proc_id or l_proc_id IS NULL)
  AND   proc.pin_id = tin.pin_id (+)
  AND   tin.pta_id = pta.id (+)
  AND   tin.date_finished (+) IS NULL   
  AND EXISTS ( SELECT 1
               FROM vw_use_pro_proc_active vupp
               WHERE vupp.ind_active = 'Y'
               AND   vupp.proc_id = proc.proc_id
               AND   vupp.pro_id = proc.pro_id
               AND   vupp.use_id = g_use_id 
               )  
  AND (proc.proc_id = l_proc_id OR l_proc_id IS NULL)
  AND proc.pro_id = g_pro_id
  AND ius.id = proc.use_id_start
  AND nus.id (+) = tin.use_id_execute;
 
-- DA specific
CURSOR c_dap (b_dap_id NUMBER) IS
  SELECT dap.dot_id
  ,      dap.subject
  ,      dap.doc_number
  ,      dap.revision_number
  ,      dot.name   dot_name
  FROM document_approvals  dap
  ,    document_types dot
  WHERE  dap.id = b_dap_id
  AND dot.id = dap.dot_id;
 
-- ECT specific
CURSOR c_ect (b_ect_id NUMBER, b_pin_id NUMBER, b_proc_id NUMBER) IS
SELECT   ect.agr_id               agr_id     
  ,      agr.po_nr                agr_po_nr
  ,      agr.description          agr_description
  ,      ect.rec_com_id           rec_com_id
  ,      aco.name                 rec_com_name  
  ,      ect.acc_use_id           acc_use_id
  ,      aus.name                 acc_use_name    
  ,      ect.issue_com_id         issue_com_id
  ,      ico.name                 issue_com_name  
  ,      ect.use_ect_id           use_ect_id
  ,      eus.name                 use_ect_name    
  ,      ect.target_date          target_date
  ,      ect.target_com_id        target_com_id
  ,      tco.name                 target_com_name  
  ,      tin1.date_started        complete_started
  ,      tin1.date_finished       complete_finished
  ,      tin2.date_started        accept_started
  ,      tin2.date_finished       accept_finished
  FROM ects               ect
  ,    agreements         agr 
  ,    companies          aco  
  ,    users              aus
  ,    companies          ico  
  ,    users              eus
  ,    companies          tco  
  ,    process_tasks      pta1
  ,    task_instances     tin1
  ,    process_tasks      pta2
  ,    task_instances     tin2
  WHERE ect.id             = b_ect_id
  AND   ect.agr_id         = agr.id 
  AND   ect.rec_com_id     = aco.id (+)
  AND   ect.acc_use_id     = aus.id (+) 
  AND   ect.issue_com_id   = ico.id (+) 
  AND   ect.use_ect_id     = eus.id (+)
  AND   ect.target_com_id  = tco.id
  AND   pta1.pro_id        = b_proc_id
  AND   pta1.name          like 'Complete%'
  AND   pta2.pro_id        = b_proc_id
  AND   pta2.name          like 'Accept%'
  AND   tin1.id (+)        = b_pin_id
  AND   tin1.pta_id (+)    = pta1.id
  AND   tin2.id (+)        = b_pin_id
  AND   tin2.pta_id (+)    = pta2.id; 
 
-- ir wbs numbers
CURSOR c_ir_wbs (b_irq_id NUMBER) IS
  SELECT iwb.wnu_id       wnu_id
  ,      wbs.nr           wnu_nr
  ,      wbs.description  wnu_description
  FROM ir_wbs_numbers       iwb
  ,    wbs_numbers          wbs
  WHERE iwb.irq_id = b_irq_id
  AND wbs.id = iwb.wnu_id
  ORDER BY iwb.wnu_id;
 
-- ect wbs numbers
CURSOR c_ect_wbs (b_ect_id NUMBER) IS
  SELECT ewb.wnu_id       wnu_id
  ,      wbs.nr           wnu_nr
  ,      wbs.description  wnu_description
  FROM ect_wbs_numbers      ewb
  ,    wbs_numbers          wbs
  WHERE ewb.ect_id = b_ect_id
  AND wbs.id = ewb.wnu_id
  ORDER BY ewb.wnu_id;
 
-- ei wbs numbers
CURSOR c_eis_wbs (b_eis_id NUMBER) IS
  SELECT ewb.wnu_id       wnu_id
  ,      wbs.nr           wnu_nr
  ,      wbs.description  wnu_description
  FROM ei_wbs_numbers       ewb
  ,    wbs_numbers          wbs
  WHERE ewb.eis_id = b_eis_id
  AND wbs.id = ewb.wnu_id
  ORDER BY ewb.wnu_id;
 
-- documents within a group
CURSOR c_dgr_docs (b_ctx_id NUMBER) IS
  SELECT doc.id       doc_id
  ,      doc.filename filename
  FROM documents doc
  WHERE doc.ctx_id = b_ctx_id
  ORDER BY doc.id;
 
-- get ctx_table
CURSOR c_ctx IS
  SELECT ctx_table
  FROM processes pro
  WHERE id = l_proc_id;
 
-- get DA submission date
CURSOR c_pin (b_pin_id NUMBER) IS
  SELECT pin.date_finished
  FROM process_instances pin
  WHERE pin.id = b_pin_id;
 
-- get ECT extra info
--CURSOR c_ect (b_ect_id NUMBER) IS  --, b_pin_id NUMBER, b_proc_id NUMBER) IS
--SELECT ect.use_ect_id       use_ect_id
--,      use1.name            use_ect_name
--,      tin1.date_started    complete_started
--,      tin1.date_finished   complete_finished
--,      ect.acc_use_id       acc_use_id
--,      use2.name            acc_use_name
--,      tin2.date_started    accept_start
--,      tin2.date_finished   accept_finished
--,      ect.target_date      target_date
--FROM ects             ect
--,    users            use1
--,    users            use2
--,    process_tasks    pta1
--,    task_instances   tin1
--,    process_tasks    pta2
--,    task_instances   tin2
--WHERE ect.id          = b_ect_id
--AND   use1.id         = ect.use_ect_id
--AND   use2.id         = ect.acc_use_id
--AND   pta1.pro_id     = 1 --b_proc_id
--AND   pta1.name       like 'Complete%'
--AND   pta2.pro_id     = 1 --b_proc_id
--AND   pta2.name       like 'Accept%'
--AND   tin1.id (+)     = 1 --b_pin_id
--AND   tin1.pta_id (+) = pta1.id
--AND   tin2.id (+)     = b_pin_id
--AND   tin2.pta_id (+) = pta2.id;
 
BEGIN
 
 -- Init
 g_module   := 'pk_api.get_user_project_processes';
 g_location := '1';
 
 l_proc_id := TO_NUMBER(pk_xml_api.get_tag_data(g_message,'<proc_id>'));
 
 OPEN c_ctx;
 FETCH c_ctx into l_ctx_table;
 CLOSE c_ctx;
 
 l_columns := pk_xml_api.create_element('column',pk_xml_api.create_element('column_seq','1') ||
                                                 pk_xml_api.create_save_element('column_name','Nr.')
                                                  ); 
 
 l_columns := l_columns || pk_xml_api.create_element('column',pk_xml_api.create_element('column_seq','2') ||
                                                 pk_xml_api.create_save_element('column_name','Initiator')
                                                  ); 
 
 l_columns := l_columns || pk_xml_api.create_element('column',pk_xml_api.create_element('column_seq','3') ||
                                                 pk_xml_api.create_save_element('column_name','Subject')
                                                  ); 
 
 l_columns := l_columns || pk_xml_api.create_element('column',pk_xml_api.create_element('column_seq','4') ||
                                                 pk_xml_api.create_save_element('column_name','Next Task / With')
                                                  ); 
 
 l_columns := l_columns || pk_xml_api.create_element('column',pk_xml_api.create_element('column_seq','5') ||
                                                 pk_xml_api.create_save_element('column_name','Since')
                                                  ); 
 
 IF l_ctx_table = 'information_requests' THEN -- IR
 
   l_columns := l_columns || pk_xml_api.create_element('column',pk_xml_api.create_element('column_seq','6') ||
                                                 pk_xml_api.create_save_element('column_name','WBS')
                                                  ); 
 END IF;
 
 IF l_ctx_table = 'document_approvals' THEN -- DA
 
   l_columns := l_columns || pk_xml_api.create_element('column',pk_xml_api.create_element('column_seq','7') ||
                                                 pk_xml_api.create_save_element('column_name','Document Type')
                                                  ); 
 
   l_columns := l_columns || pk_xml_api.create_element('column',pk_xml_api.create_element('column_seq','8') ||
                                                 pk_xml_api.create_save_element('column_name','Document Number')
                                                  ); 
 
   l_columns := l_columns || pk_xml_api.create_element('column',pk_xml_api.create_element('column_seq','9') ||
                                                 pk_xml_api.create_save_element('column_name','Document Title')
                                                  ); 
 
   l_columns := l_columns || pk_xml_api.create_element('column',pk_xml_api.create_element('column_seq','10') ||
                                                 pk_xml_api.create_save_element('column_name','Revision Number')
                                                  ); 
 
   l_columns := l_columns || pk_xml_api.create_element('column',pk_xml_api.create_element('column_seq','11') ||
                                                 pk_xml_api.create_save_element('column_name','Files')
                                                  ); 
 
   l_columns := l_columns || pk_xml_api.create_element('column',pk_xml_api.create_element('column_seq','12') ||
                                                 pk_xml_api.create_save_element('column_name','Submission Date')
                                                  ); 
 
 END IF;
 
 IF l_ctx_table = 'ects' THEN -- ECT
 
   l_columns := l_columns || pk_xml_api.create_element('column',pk_xml_api.create_element('column_seq','6') ||
                                                 pk_xml_api.create_save_element('column_name','Company')
                                                  ); 
   l_columns := l_columns || pk_xml_api.create_element('column',pk_xml_api.create_element('column_seq','7') ||
                                                 pk_xml_api.create_save_element('column_name','PO Number')
                                                  ); 
   l_columns := l_columns || pk_xml_api.create_element('column',pk_xml_api.create_element('column_seq','8') ||
                                                 pk_xml_api.create_save_element('column_name','WBBS')
                                                  ); 
   l_columns := l_columns || pk_xml_api.create_element('column',pk_xml_api.create_element('column_seq','9') ||
                                                 pk_xml_api.create_save_element('column_name','ECT Definer')
                                                  ); 
   l_columns := l_columns || pk_xml_api.create_element('column',pk_xml_api.create_element('column_seq','10') ||
                                                 pk_xml_api.create_save_element('column_name','Defined on')
                                                  ); 
   l_columns := l_columns || pk_xml_api.create_element('column',pk_xml_api.create_element('column_seq','11') ||
                                                 pk_xml_api.create_save_element('column_name','ECT Engineer')
                                                  ); 
   l_columns := l_columns || pk_xml_api.create_element('column',pk_xml_api.create_element('column_seq','12') ||
                                                 pk_xml_api.create_save_element('column_name','Completed on')
                                                  ); 
   l_columns := l_columns || pk_xml_api.create_element('column',pk_xml_api.create_element('column_seq','13') ||
                                                 pk_xml_api.create_save_element('column_name','ECT Accepter')
                                                  ); 
   l_columns := l_columns || pk_xml_api.create_element('column',pk_xml_api.create_element('column_seq','14') ||
                                                 pk_xml_api.create_save_element('column_name','Accepted on')
                                                  ); 
   l_columns := l_columns || pk_xml_api.create_element('column',pk_xml_api.create_element('column_seq','15') ||
                                                 pk_xml_api.create_save_element('column_name','Accepter comments')
                                                  ); 
   l_columns := l_columns || pk_xml_api.create_element('column',pk_xml_api.create_element('column_seq','16') ||
                                                 pk_xml_api.create_save_element('column_name','Target Date')
                                                  ); 
 END IF;
 
 IF l_ctx_table = 'eis' THEN -- EI
 
   l_columns := l_columns || pk_xml_api.create_element('column',pk_xml_api.create_element('column_seq','6') ||
                                                 pk_xml_api.create_save_element('column_name','WBS')
                                                  ); 
 END IF;
 
 l_columns := pk_xml_api.create_element('columns', l_columns);
 
 l_response := l_columns;
 
 FOR r_proc IN c_proc LOOP
   l_process:= 
--      pk_xml_api.create_element('process',  
         pk_xml_api.create_element('proc_id',r_proc.proc_id) || 
         pk_xml_api.create_element('abbr',r_proc.abbr) ||          
         pk_xml_api.create_element('pin_id',r_proc.pin_id) ||
         pk_xml_api.create_element('wf_nr',r_proc.wf_nr) || 
         pk_xml_api.create_save_element('subject',r_proc.subject) || 
         pk_xml_api.create_element('initiator',r_proc.initiator) || 
         pk_xml_api.create_element('init_name',r_proc.init_name) || 
         pk_xml_api.create_element('date_started',to_char(r_proc.date_started,'dd-mm-yyyy hh24:mi:ss')) || 
         pk_xml_api.create_element('state',r_proc.state) ||           
         pk_xml_api.create_save_element('next_task',r_proc.next_task) || 
         pk_xml_api.create_element('next_user',r_proc.next_user) ||
         pk_xml_api.create_element('next_name',r_proc.next_name);
--   );  
 
-- IR Specific
 
   IF r_proc.ctx_table = 'information_requests' and r_proc.proc_id = l_proc_id THEN
 
     l_wnu_list := NULL;
 
     FOR r_ir_wbs IN c_ir_wbs (r_proc.ctx_id) LOOP
       l_wnu_list := l_wnu_list || pk_xml_api.create_element('wnu', pk_xml_api.create_element('wnu_id',r_ir_wbs.wnu_id) || 
                   pk_xml_api.create_save_element('wnu_nr',r_ir_wbs.wnu_nr) ||
                   pk_xml_api.create_save_element('wnu_description',r_ir_wbs.wnu_description)); 
     END LOOP;   
  
     l_wnu_list := pk_xml_api.create_element('wbs_list',l_wnu_list);   
 
     l_process := l_process || l_wnu_list;
 
   END IF;
 
-- ECT Specific
 
   IF r_proc.ctx_table = 'ects' and r_proc.proc_id = l_proc_id THEN
 
     FOR r_ect IN c_ect (r_proc.ctx_id, r_proc.pin_id , r_proc.proc_id) LOOP
      l_process := l_process || pk_xml_api.create_element('com_id',r_ect.target_com_id) ||
                                pk_xml_api.create_save_element('com_name',r_ect.target_com_name);
      l_process := l_process || pk_xml_api.create_save_element('agr_id',r_ect.agr_id) ||
                                pk_xml_api.create_save_element('agr_po_nr',r_ect.agr_po_nr) ||
                                pk_xml_api.create_save_element('agr_description',r_ect.agr_description);
      l_process := l_process || pk_xml_api.create_element('use_ect_id',r_ect.use_ect_id) ||
                                pk_xml_api.create_save_element('use_ect_name',r_ect.use_ect_name);
      l_process := l_process || pk_xml_api.create_element('completed_date',to_char(r_ect.complete_finished,'dd-mm-yyyy'));
      l_process := l_process || pk_xml_api.create_element('acc_use_id',r_ect.acc_use_id) ||
                                pk_xml_api.create_save_element('acc_use_name',r_ect.acc_use_name);
      l_process := l_process || pk_xml_api.create_element('accepted_date',to_char(r_ect.accept_finished,'dd-mm-yyyy'));
      l_process := l_process || pk_xml_api.create_element('target_date',to_char(r_ect.target_date,'dd-mm-yyyy'));
 
     END LOOP;   
 
     l_wnu_list := NULL;
 
     FOR r_ect_wbs IN c_ect_wbs (r_proc.ctx_id) LOOP
       l_wnu_list := l_wnu_list || pk_xml_api.create_element('wnu', pk_xml_api.create_element('wnu_id',r_ect_wbs.wnu_id) || 
                   pk_xml_api.create_save_element('wnu_nr',r_ect_wbs.wnu_nr) ||
                   pk_xml_api.create_save_element('wnu_description',r_ect_wbs.wnu_description)); 
     END LOOP;   
  
     l_wnu_list := pk_xml_api.create_element('wbs_list',l_wnu_list);   
 
     l_process := l_process || l_wnu_list;
 
   END IF;
 
-- EI Specific
 
   IF r_proc.ctx_table = 'eis' and r_proc.proc_id = l_proc_id THEN
 
     l_wnu_list := NULL;
 
     FOR r_eis_wbs IN c_eis_wbs (r_proc.ctx_id) LOOP
       l_wnu_list := l_wnu_list || pk_xml_api.create_element('wnu', pk_xml_api.create_element('wnu_id',r_eis_wbs.wnu_id) || 
                   pk_xml_api.create_save_element('wnu_nr',r_eis_wbs.wnu_nr) ||
                   pk_xml_api.create_save_element('wnu_description',r_eis_wbs.wnu_description)); 
     END LOOP;   
  
     l_wnu_list := pk_xml_api.create_element('wbs_list',l_wnu_list);   
 
     l_process := l_process || l_wnu_list;
 
   END IF;
 
-- DA Specific
 
   IF r_proc.ctx_table = 'document_approvals' and r_proc.proc_id = l_proc_id THEN
      FOR r_dap IN c_dap (r_proc.ctx_id) LOOP
      l_process := l_process || pk_xml_api.create_save_element('document_type',r_dap.dot_name) ||
                   pk_xml_api.create_save_element('document_number',r_dap.doc_number) ||
                   pk_xml_api.create_save_element('document_title',r_dap.subject) ||
            pk_xml_api.create_element('revision_number',r_dap.revision_number);
      END LOOP;   
 
      l_files := NULL;
 
      FOR r_dgr_docs IN c_dgr_docs (r_proc.ctx_id) LOOP
         l_files := l_files || pk_xml_api.create_element('file',
                     pk_xml_api.create_element('doc_id',r_dgr_docs.doc_id) || 
                     pk_xml_api.create_save_element('filename',r_dgr_docs.filename)
                                                   ); 
      END LOOP;   
 
      l_files := pk_xml_api.create_element('files', l_files);
 
      l_process := l_process || l_files;
 
      OPEN c_pin (r_proc.pin_id);
      FETCH c_pin into l_date_finished;
      CLOSE c_pin;
 
      l_process := l_process || pk_xml_api.create_element('submit_date', to_char(l_date_finished,'dd-mm-yyyy'));
 
   END IF;
 
   l_process := pk_xml_api.create_element('process', l_process);
 
   l_response := l_response || l_process;                          
 
 END LOOP; 
 
 RETURN pk_xml_api.create_element('processes',l_response);
 
END;
FUNCTION DISMISS_USER_TASK
 RETURN VARCHAR2
 IS
-- Dismiss specific task for given user
 
l_tin_id NUMBER;
BEGIN
 
  l_tin_id   := TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<tin_id>'),1,10));
  pk_wf_api.dismiss_user_task( p_use_id => g_use_id
                             , p_tin_id => l_tin_id);
 
  -- Result
  RETURN pk_xml_api.create_element('result','Ok.');
 
END;
FUNCTION SET_TASK_SHARE_USERS
 RETURN VARCHAR2
 IS
-- add task share users
 
l_error        VARCHAR2(4000);
l_tin_id       NUMBER;
l_share_use    APEX_APPLICATION_GLOBAL.VC_ARR2;
i              NUMBER;
BEGIN
 
  -- task instance to add shares
  l_tin_id := TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<tin_id>'),1,10));
 
  -- fill the array
  i := 1;
  WHILE TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<share_use_id>',i),1,10)) IS NOT NULL LOOP
     l_share_use(i) := TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<share_use_id>',i),1,10));
     i:=i+1;
  END LOOP;
 
  -- Add task share users
  pk_wf_api.set_task_share_users( p_tin_id => l_tin_id
                                , p_share_use => l_share_use);
 
  RETURN pk_xml_api.create_element('result','Ok.');
 
EXCEPTION WHEN OTHERS THEN
    l_error := SQLERRM;
    pk_log.log_message( p_module  => 'pk_api.set_task_share_user'
                      , p_message => 'Unexpected error, error:'||substr(l_error,1,3000) || ' tin_id:'||l_tin_id );
    raise_application_error( -20001, 'Unexpected error when executing this task.' );
END;
FUNCTION GET_PROJECT_PACKAGES
 RETURN CLOB
 IS
-- Get project packages           
 
l_response CLOB;
l_tasks    NUMBER;
l_alerts   NUMBER;
l_shared   NUMBER;
l_news     NUMBER; 
l_docs     NUMBER;
 
l_pac_all_tasks   NUMBER;
l_pac_tasks       NUMBER;
l_pac_alerts      NUMBER;
l_pac_shared      NUMBER;
l_pac_news        NUMBER;
l_pac_docs        NUMBER;
 
l_pac        CLOB; 
l_pack_wnu   CLOB;
 
-- packages
CURSOR c_pac IS
  SELECT pac.id            pac_id
  ,      pac.pack_number   pack_number
  ,      pac.pack_use_id   pack_use_id
  ,      pus.name          pack_use_name
  ,      pac.subject       pack_subject              
  ,      pin.date_started  pack_created
  ,      pin.id            pin_id
FROM packages pac
  ,    users    pus
  ,    process_instances pin
  WHERE pac.pro_id = g_pro_id
  AND   pus.id     = pac.pack_use_id
  AND   pac.id = pin.ctx_id
  ORDER BY pac.pack_number;
 
-- package wbs numbers
CURSOR c_pac_wbs (b_pac_id NUMBER) IS
  SELECT pwb.wnu_id       pack_wnu_id
  ,      wbs.nr           pack_wnu_nr
  ,      wbs.description  pack_wnu_description
  FROM package_wbs_numbers  pwb
  ,    wbs_numbers          wbs
  WHERE pwb.pac_id = b_pac_id
  AND wbs.id = pwb.wnu_id
  ORDER BY pwb.wnu_id;
 
BEGIN              
 
 -- Init
 g_module   := 'pk_api.get_project_packages';
 g_location := '1';
 
 -- general info 
 l_tasks := pk_wf_api.get_nr_of_use_tasks( p_use_id=> g_use_id
                                         , p_pro_id=> g_pro_id);
 l_alerts := pk_wf_api.get_nr_of_use_alerts( p_use_id => g_use_id
                                         , p_pro_id => g_pro_id);  
 l_shared := pk_wf_api.get_nr_of_use_shared( p_use_id => g_use_id
                                         , p_pro_id => g_pro_id);         
 l_news   := pk_wf_api.get_nr_of_use_news( p_use_id => g_use_id
                                       , p_pro_id => g_pro_id); 
 l_docs   := pk_wf_api.get_nr_of_docs( p_use_id => g_use_id
                                       , p_pro_id => g_pro_id); 
 
 l_response := pk_xml_api.create_element('total_tasks',l_tasks) ||      
               pk_xml_api.create_element('total_alerts',l_alerts) || 
               pk_xml_api.create_element('total_shared',l_shared) || 
               pk_xml_api.create_element('total_news',l_news) || 
               pk_xml_api.create_element('total_docs',l_docs);
 
 -- packages info
 
 -- wbs
 FOR r_pac IN c_pac LOOP
   l_pac_all_tasks := pk_wf_api.get_nr_of_all_tasks( p_pro_id=> g_pro_id
                                         , p_pac_id=> r_pac.pac_id);
   l_pac_tasks := pk_wf_api.get_nr_of_use_tasks( p_use_id=> g_use_id
                                         , p_pro_id=> g_pro_id
                                         , p_pac_id=> r_pac.pac_id);
   l_pac_alerts := pk_wf_api.get_nr_of_use_alerts( p_use_id=> g_use_id
                                         , p_pro_id=> g_pro_id
                                         , p_pac_id=> r_pac.pac_id);
   l_pac_shared := pk_wf_api.get_nr_of_use_shared( p_use_id=> g_use_id
                                         , p_pro_id=> g_pro_id
                                         , p_pac_id=> r_pac.pac_id);
   l_pac_news := pk_wf_api.get_nr_of_use_news( p_use_id=> g_use_id
                                         , p_pro_id=> g_pro_id
                                         , p_pac_id=> r_pac.pac_id);
   l_pac_docs := pk_wf_api.get_nr_of_docs( p_use_id=> g_use_id
                                         , p_pro_id=> g_pro_id
                                         , p_pac_id=> r_pac.pac_id);
 
   l_pack_wnu := NULL;
 
   FOR r_pac_wbs IN c_pac_wbs (r_pac.pac_id) LOOP
      l_pack_wnu := l_pack_wnu || pk_xml_api.create_element('wbs_number', pk_xml_api.create_element('wnu_id',r_pac_wbs.pack_wnu_id) || 
                   pk_xml_api.create_save_element('nr',r_pac_wbs.pack_wnu_nr) ||
                   pk_xml_api.create_save_element('description',r_pac_wbs.pack_wnu_description)); 
   END LOOP;   
 
   l_pack_wnu := pk_xml_api.create_element('wbs_numbers',l_pack_wnu);   
 
 
   l_pac := l_pac || pk_xml_api.create_element('package',
                                 pk_xml_api.create_element('pac_id',r_pac.pac_id)  ||
                                 pk_xml_api.create_element('pack_number',r_pac.pack_number)||
                                 pk_xml_api.create_save_element('pack_subject',r_pac.pack_subject)||
                                 pk_xml_api.create_element('pack_use_id',r_pac.pack_use_id)||
                                 pk_xml_api.create_save_element('pack_use_name',r_pac.pack_use_name)||
                                 pk_xml_api.create_save_element('pack_created',to_char(r_pac.pack_created,'dd-mm-yyyy'))||
                                 l_pack_wnu ||
                                 pk_xml_api.create_element('pin_id',r_pac.pin_id)  ||
                                 pk_xml_api.create_element('nr_of_docs_uploaded',l_pac_docs)||
                                 pk_xml_api.create_element('nr_of_all_tasks',l_pac_all_tasks)||
                                 pk_xml_api.create_element('nr_of_my_tasks',l_pac_tasks)||
                                 pk_xml_api.create_element('nr_of_my_alerts',l_pac_alerts)||
                                 pk_xml_api.create_element('nr_of_my_trackings',1)||
                                 pk_xml_api.create_element('nr_of_my_news',l_pac_news)
                                                );
 END LOOP;     
 l_pac := pk_xml_api.create_element('packages',l_pac); 
 
 l_response := l_response || l_pac;
 
 -- response
 RETURN l_response;  
    
END;
FUNCTION GET_PACKAGE_INFO
 RETURN CLOB
 IS
-- Get package info
 
l_response     CLOB;
 
l_pac_id      NUMBER;
 
l_pac_all_tasks   NUMBER;
l_pac_tasks       NUMBER;
l_pac_alerts      NUMBER;
l_pac_shared      NUMBER;
l_pac_news        NUMBER;
 
-- package info
CURSOR c_pac (b_pac_id NUMBER) IS
  SELECT pac.id            pac_id
  ,      pac.pack_number   pack_number
  ,      pac.pack_use_id   pack_use_id
  ,      pus.name          pack_use_name
  ,      pac.subject       pack_subject              
  ,      pin.date_started  pack_created
  ,      pin.proc_id       proc_id
  FROM packages pac
  ,    users    pus
  ,    process_instances pin
  WHERE pac.pro_id = g_pro_id
  AND   pus.id     = pac.pack_use_id
  AND   pac.id = pin.ctx_id
  AND   pac.id = b_pac_id;
BEGIN              
 
 -- Init
 g_module   := 'pk_api.get_package_info';
 g_location := '1';
 
 l_pac_id      := TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<pac_id>'),1,10)); 
 
-- package info
 
 l_response := NULL;
 
 FOR r_pac IN c_pac(b_pac_id => l_pac_id) LOOP
  
   l_pac_all_tasks := pk_wf_api.get_nr_of_all_tasks( p_pro_id=> g_pro_id
                                         , p_pac_id=> r_pac.pac_id);
   l_pac_tasks := pk_wf_api.get_nr_of_use_tasks( p_use_id=> g_use_id
                                         , p_pro_id=> g_pro_id
                                         , p_pac_id=> r_pac.pac_id);
   l_pac_alerts := pk_wf_api.get_nr_of_use_alerts( p_use_id=> g_use_id
                                         , p_pro_id=> g_pro_id
                                         , p_pac_id=> r_pac.pac_id);
   l_pac_shared := pk_wf_api.get_nr_of_use_shared( p_use_id=> g_use_id
                                         , p_pro_id=> g_pro_id
                                         , p_pac_id=> r_pac.pac_id);
   l_pac_news := pk_wf_api.get_nr_of_use_news( p_use_id=> g_use_id
                                         , p_pro_id=> g_pro_id
                                         , p_pac_id=> r_pac.pac_id);
 
   l_response := l_response || pk_xml_api.create_element('package',
                                 pk_xml_api.create_element('pac_id',r_pac.pac_id)  ||
                                 pk_xml_api.create_element('proc_id',r_pac.proc_id)  ||
                                 pk_xml_api.create_element('pack_number',r_pac.pack_number)||
                                 pk_xml_api.create_save_element('pack_subject',r_pac.pack_subject)||
                                 pk_xml_api.create_element('pack_use_id',r_pac.pack_use_id)||
                                 pk_xml_api.create_save_element('pack_use_name',r_pac.pack_use_name)||
                                 pk_xml_api.create_save_element('pack_created',to_char(r_pac.pack_created,'dd-mm-yyyy'))||
                                 pk_xml_api.create_element('nr_of_docs_uploaded',10)||
                                 pk_xml_api.create_element('nr_of_all_tasks',l_pac_all_tasks)||
                                 pk_xml_api.create_element('nr_of_my_tasks',l_pac_tasks)||
                                 pk_xml_api.create_element('nr_of_my_alerts',l_pac_alerts)||
                                 pk_xml_api.create_element('nr_of_my_trackings',1)||
                                 pk_xml_api.create_element('nr_of_my_news',l_pac_news)
                                                );
 END LOOP;     
 
 -- response
 RETURN l_response;  
    
END;
FUNCTION GET_PACKAGE_DOCUMENTS
 RETURN CLOB
 IS
-- Get package documents           
 
l_response     CLOB;
 
l_doc           VARCHAR2(10000);
l_files         VARCHAR2(10000);
l_init_use_id   NUMBER;
l_init_use_name VARCHAR2(100);
l_wbs           VARCHAR2(10000);
 
l_wf_in         VARCHAR2(10000);
l_wf_out        VARCHAR2(10000);
 
l_pac_id      NUMBER;
 
-- package_documents
CURSOR c_doc IS
  SELECT DISTINCT  dgr.id        dgr_id
  ,      dgr.doc_number          doc_number
  ,      dgr.subject             doc_title
  ,      dgr.revision_number     rev_number
  ,      dgr.timestamp           doc_timestamp
  ,      dgr.ctx_id              ctx_id
  FROM document_groups         dgr
  ,    document_group_usages   dga
  ,    (select 'ects'                 ctx_table
        ,       ewn.ect_id            id
        ,       ewn.wnu_id            wnu_id
        from ect_wbs_numbers ewn
           union
        select 'information_requests' ctx_table
        ,       iwn.irq_id            id
        ,       iwn.wnu_id            wnu_id
        from ir_wbs_numbers iwn
           union
        select 'eis'                  ctx_table
        ,       ewn.eis_id            id
        ,       ewn.wnu_id            wnu_id
        from ei_wbs_numbers ewn) ctx
  WHERE dgr.id = dga.dgr_id
  AND dgr.pro_id = g_pro_id
  AND ctx.ctx_table = dga.ctx_table
  AND ctx.id = dga.ctx_id
  AND ctx.wnu_id IN
   (SELECT pwb.wnu_id
    FROM packages pac
    ,    package_wbs_numbers pwb
    WHERE pac.id = l_pac_id
    AND pwb.pac_id = pac.id)
  ORDER BY dgr.doc_number;
 
-- documents within a group
CURSOR c_dgr_docs (b_dgr_id NUMBER) IS
  SELECT doc.id       doc_id
  ,      doc.filename filename
  FROM documents doc
  WHERE doc.dgr_id = b_dgr_id
  ORDER BY doc.id;
 
-- get initiator
CURSOR c_use (b_ctx_id NUMBER) IS
  SELECT pin.use_id    init_use_id
  ,      use.name      init_use_name
  FROM process_instances pin
  ,    users use
  WHERE pin.ctx_id = b_ctx_id
  AND use.id = pin.use_id;
 
--SELECT name FROM users use
--WHERE use.id = b_use_id;
 
-- get wbs list
CURSOR c_wbs (b_dgr_id NUMBER) IS
SELECT DISTINCT ctx.wnu_id        wnu_id
,               wbs.nr            wnu_nr
,               wbs.description   wnu_description
FROM document_group_usages dgu
,    (select 'ects'                 ctx_table
        ,       ewn.ect_id            id
        ,       ewn.wnu_id            wnu_id
        from ect_wbs_numbers ewn
           union
        select 'information_requests' ctx_table
        ,       iwn.irq_id            id
        ,       iwn.wnu_id            wnu_id
        from ir_wbs_numbers iwn
           union
        select 'eis'                  ctx_table
        ,       ewn.eis_id            id
        ,       ewn.wnu_id            wnu_id
        from ei_wbs_numbers ewn) ctx
,  wbs_numbers            wbs
,  package_wbs_numbers    pwn
WHERE dgu.dgr_id      = b_dgr_id
AND   ctx.ctx_table   = dgu.ctx_table
AND   ctx.id          = dgu.ctx_id
AND   wbs.id          = ctx.wnu_id
AND   pwn.pac_id      = l_pac_id
AND   pwn.wnu_id      = wbs.id;
 
-- Oude CURSOR
 
--  SELECT DISTINCT x.wnu_id     wnu_id
--  , wbs.nr            wnu_nr
--  , wbs.description   wnu_description
--  FROM (SELECT wnu_id
--        FROM document_group_usages dgu
--        ,    ects                  ect
--        WHERE dgu.dgr_id = b_dgr_id
--        AND dgu.ctx_table = 'ects'
--        AND ect.id = dgu.ctx_id) x
--  ,   wbs_numbers            wbs
--  WHERE wbs.id = x.wnu_id
--  ORDER BY wbs.nr;
 
-- get WorkFlow IN
CURSOR c_wf_in (b_dgr_id NUMBER) IS
SELECT DISTINCT pin.id            pin_id
,               pin.proc_id       proc_id
,               ctx.ctx_table     ctx_table
FROM document_group_usages dgu
,    (select 'ects'                 ctx_table
        ,       ewn.ect_id            id
        ,       ewn.wnu_id            wnu_id
        from ect_wbs_numbers ewn
           union
        select 'information_requests' ctx_table
        ,       iwn.irq_id            id
        ,       iwn.wnu_id            wnu_id
        from ir_wbs_numbers iwn
           union
        select 'eis'                  ctx_table
        ,       ewn.eis_id            id
        ,       ewn.wnu_id            wnu_id
        from ei_wbs_numbers ewn) ctx
,     process_instances          pin
WHERE dgu.dgr_id      = b_dgr_id
AND   ctx.ctx_table   = dgu.ctx_table
AND   ctx.id          = dgu.ctx_id
AND   pin.ctx_id      = ctx.id
AND   pk_api_util.equal_com(pin.use_id,g_use_id) = 'N';
 
-- get WorkFlow OUT
CURSOR c_wf_out (b_dgr_id NUMBER) IS
SELECT DISTINCT pin.id            pin_id
,               pin.proc_id       proc_id
,               ctx.ctx_table     ctx_table
FROM document_group_usages dgu
,    (select 'ects'                 ctx_table
        ,       ewn.ect_id            id
        ,       ewn.wnu_id            wnu_id
        from ect_wbs_numbers ewn
           union
        select 'information_requests' ctx_table
        ,       iwn.irq_id            id
        ,       iwn.wnu_id            wnu_id
        from ir_wbs_numbers iwn
           union
        select 'eis'                  ctx_table
        ,       ewn.eis_id            id
        ,       ewn.wnu_id            wnu_id
        from ei_wbs_numbers ewn) ctx
,     process_instances          pin
WHERE dgu.dgr_id      = b_dgr_id
AND   ctx.ctx_table   = dgu.ctx_table
AND   ctx.id          = dgu.ctx_id
AND   pin.ctx_id      = ctx.id
AND   pk_api_util.equal_com(pin.use_id,g_use_id) = 'Y';
 
-- get workflow IN list
--CURSOR c_wf_in (b_dgr_id NUMBER) IS
--SELECT ect.nr         nr
--FROM document_group_usages dgu
--,    ects                  ect
--WHERE dgu.dgr_id = b_dgr_id
--AND dgu.ctx_table = 'ects'
--AND ect.id = dgu.ctx_id;
 
BEGIN              
 
 -- Init
 g_module   := 'pk_api.get_package_documents';
 g_location := '1';
 
-- optional pac_id for returning only documents within a specific package
 l_pac_id      := TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<pac_id>'),1,10)); 
 
-- package documents
 
 l_response := NULL;
 
 FOR r_doc IN c_doc LOOP
 
   l_files := NULL;
   l_wbs := NULL;
 
   l_doc := pk_xml_api.create_element('dgr_id', r_doc.dgr_id) ||
                                    pk_xml_api.create_save_element('doc_number', r_doc.doc_number) ||
                                    pk_xml_api.create_save_element('doc_title', r_doc.doc_title) ||
                                    pk_xml_api.create_save_element('revision_number', r_doc.rev_number); 
 
   FOR r_dgr_docs IN c_dgr_docs (r_doc.dgr_id) LOOP
      l_files := l_files || pk_xml_api.create_element('file',
                   pk_xml_api.create_element('doc_id',r_dgr_docs.doc_id) || 
                   pk_xml_api.create_save_element('filename',r_dgr_docs.filename)
                                                   ); 
   END LOOP;   
 
   l_files := pk_xml_api.create_element('files', l_files);
 
   l_doc := l_doc || l_files;
 
   -- get initiator name
 
   l_init_use_id := g_use_id;
 
   FOR r_use IN c_use(b_ctx_id => r_doc.ctx_id) LOOP
 
   l_doc := l_doc || pk_xml_api.create_element('initiator',
                   pk_xml_api.create_element('init_use_id',r_use.init_use_id) || 
                   pk_xml_api.create_save_element('init_use_name',r_use.init_use_name)
                                                   );
 
   END LOOP;
 
   FOR r_wbs IN c_wbs (r_doc.dgr_id) LOOP
      l_wbs := l_wbs || pk_xml_api.create_element('wnu',
                   pk_xml_api.create_element('wnu_nr',r_wbs.wnu_nr) || 
                   pk_xml_api.create_save_element('filename',r_wbs.wnu_description)
                                                   ); 
   END LOOP;
 
   l_wbs := pk_xml_api.create_element('wbs_list',l_wbs); 
 
   l_doc := l_doc || l_wbs;
 
   l_wf_in := NULL;
 
   FOR r_wf_in IN c_wf_in(b_dgr_id => r_doc.dgr_id) LOOP
      l_wf_in := l_wf_in || pk_xml_api.create_element('wf_in', pk_xml_api.create_element('wf_in_nr', pk_wf_api.get_ctx_nr(p_pin_id=>r_wf_in.pin_id)) ||
                                                               pk_xml_api.create_element('pin_id',r_wf_in.pin_id) ||
                                                               pk_xml_api.create_element('proc_id',r_wf_in.proc_id));
   END LOOP; 
 
   l_doc := l_doc || pk_xml_api.create_element('workflow_in', l_wf_in);
 
   l_doc := l_doc || pk_xml_api.create_element('timestamp',to_char(r_doc.doc_timestamp,'dd-mm-yyyy hh24:mi:ss')) ||  
          pk_xml_api.create_element('timestamp_since',APEX_UTIL.GET_SINCE_TSWLTZ(r_doc.doc_timestamp));
 
   l_wf_out := NULL;
 
   FOR r_wf_out IN c_wf_out(b_dgr_id => r_doc.dgr_id) LOOP
      l_wf_out := l_wf_out || pk_xml_api.create_element('wf_out', pk_xml_api.create_element('wf_out_nr', pk_wf_api.get_ctx_nr(p_pin_id=>r_wf_out.pin_id)) ||
                                                               pk_xml_api.create_element('pin_id',r_wf_out.pin_id) ||
                                                               pk_xml_api.create_element('proc_id',r_wf_out.proc_id));
   END LOOP; 
 
   l_doc := l_doc || pk_xml_api.create_element('workflow_out', l_wf_out);
 
   l_doc := pk_xml_api.create_element('document', l_doc);
 
   l_response := l_response || l_doc;
 
 END LOOP;     
 
 -- response
 RETURN l_response;  
    
END;
FUNCTION GET_PROJECT_COMPANIES
 RETURN CLOB
 IS
-- Get project companies
 
l_response CLOB;
l_tasks    NUMBER;
l_alerts   NUMBER;
l_shared   NUMBER;
l_news     NUMBER;   
 
l_com_contracts   NUMBER;
l_com_all_tasks   NUMBER;
l_com_tasks       NUMBER;
l_com_shared      NUMBER;
l_com_alerts      NUMBER;
l_com_trackings   NUMBER;
l_com_news        NUMBER;
 
l_com        VARCHAR2(10000); 
 
l_com_type      VARCHAR2(10);
 
-- companies
CURSOR c_com IS
  SELECT com.id              com_id
  ,      com.name            com_name
  ,      pco.date_from       com_created
  FROM project_companies pco
  ,    companies com
  WHERE pco.pro_id = g_pro_id
  AND com.id = pco.com_id
  AND com.type = l_com_type;
BEGIN              
 
 -- Init
 g_module   := 'pk_api.get_project_companies';
 g_location := '1';
 
-- get the company type (E for companies, I for departments)
 l_com_type      := SUBSTR(pk_xml_api.get_tag_data(g_message,'<com_type>'),1,10); 
 
 -- general info 
 l_tasks := pk_wf_api.get_nr_of_use_tasks( p_use_id=> g_use_id
                                         , p_pro_id=> g_pro_id);
 l_alerts := pk_wf_api.get_nr_of_use_alerts( p_use_id => g_use_id
                                         , p_pro_id => g_pro_id);  
 l_shared := pk_wf_api.get_nr_of_use_shared( p_use_id => g_use_id
                                         , p_pro_id => g_pro_id);         
 l_news   := pk_wf_api.get_nr_of_use_news( p_use_id => g_use_id
                                       , p_pro_id => g_pro_id); 
 
 l_response := pk_xml_api.create_element('total_tasks',l_tasks) ||      
               pk_xml_api.create_element('total_alerts',l_alerts) || 
               pk_xml_api.create_element('total_shared',l_shared) || 
               pk_xml_api.create_element('total_news',l_news);
 
 -- company info
 
 -- wbs
 FOR r_com IN c_com LOOP
   l_com_all_tasks := pk_wf_api.get_nr_of_all_tasks( p_pro_id=> g_pro_id
                                         , p_com_id=> r_com.com_id);
   l_com_tasks := pk_wf_api.get_nr_of_use_tasks( p_use_id=> g_use_id
                                         , p_pro_id=> g_pro_id
                                         , p_com_id=> r_com.com_id);
   l_com_alerts := pk_wf_api.get_nr_of_use_alerts( p_use_id=> g_use_id
                                         , p_pro_id=> g_pro_id
                                         , p_com_id=> r_com.com_id);
   l_com_shared := pk_wf_api.get_nr_of_use_shared( p_use_id=> g_use_id
                                         , p_pro_id=> g_pro_id
                                         , p_com_id=> r_com.com_id);
   l_com_news := pk_wf_api.get_nr_of_use_news( p_use_id=> g_use_id
                                         , p_pro_id=> g_pro_id
                                         , p_com_id=> r_com.com_id);
 
   l_com_contracts := 5;
--   l_com_tasks     := 5;
--   l_com_shared    := 5;
--   l_com_alerts    := 5;
   l_com_trackings := 2;
--   l_com_news      := 5;
 
   l_com := l_com || pk_xml_api.create_element('company',
                                 pk_xml_api.create_element('com_id',r_com.com_id)  ||
                                 pk_xml_api.create_save_element('com_name',r_com.com_name)||
                                 pk_xml_api.create_save_element('com_created',to_char(r_com.com_created,'dd-mm-yyyy'))||
                                 pk_xml_api.create_element('nr_of_contracts',l_com_contracts)||
                                 pk_xml_api.create_element('nr_of_all_tasks',l_com_all_tasks)||
                                 pk_xml_api.create_element('nr_of_my_tasks',l_com_tasks)||
                                 pk_xml_api.create_element('nr_of_my_shared',l_com_shared)||
                                 pk_xml_api.create_element('nr_of_my_alerts',l_com_alerts)||
                                 pk_xml_api.create_element('nr_of_my_trackings',l_com_trackings)||
                                 pk_xml_api.create_element('nr_of_my_news',l_com_news)
                                                );
 END LOOP;     
 l_com := pk_xml_api.create_element('companies',l_com); 
 
 l_response := l_response || l_com;
 
 -- response
 RETURN l_response;  
    
END;
 
FUNCTION GET_GRAPH_DATA
 RETURN CLOB
 IS
-- Get Graph Data
 
l_graph_id    NUMBER;
i             NUMBER;
l_workdate    DATE;     
 
l_process     CLOB;
l_period      CLOB;
l_response    CLOB;
 
-- cusrsors
 
CURSOR c_stats IS
SELECT pin.proc_id        proc_id
,      proc.name          proc_name
,      proc.abbreviation  proc_abbr
,      count(*)           nr_of_proc
FROM process_instances pin
,    processes proc
WHERE pin.pro_id = g_pro_id
AND ((l_graph_id = 1 AND pin.date_started between ADD_MONTHS(last_day(l_workdate), -1) + 1 AND last_day(l_workdate))
OR (l_graph_id = 2 AND pin.date_finished between ADD_MONTHS(last_day(l_workdate), -1) + 1 AND last_day(l_workdate)))
AND proc.id = pin.proc_id
GROUP BY pin.proc_id, proc.name, proc.abbreviation;
 
BEGIN              
 
 -- Init
 g_module   := 'pk_api.get_graph_data';
 g_location := '1';
 
-- get graph_id --> for the moment 1 = started processes per month; 2 = finished_processes per month
 l_graph_id      := TO_NUMBER(SUBSTR(pk_xml_api.get_tag_data(g_message,'<graph_id>'),1,10)); 
 
 l_response := pk_xml_api.create_element('graph_id', l_graph_id);
 
 IF l_graph_id = 1 THEN
    l_response := l_response || pk_xml_api.create_element('graph_name', 'Started WorkFlow per Month');
 ELSE
    l_response := l_response || pk_xml_api.create_element('graph_name', 'Finished WorkFlow per Month');
 END IF;
 
  l_period   := NULL;
  
  FOR i IN 0..6 LOOP
     l_workdate := ADD_MONTHS(sysdate, -6 + i);
--     l_period := l_period || pk_xml_api.create_element('period_id',''); -- later vullen als we een tabel hebben
--     l_period := l_period || pk_xml_api.create_element('period_year',TO_CHAR(l_workdate,'YYYY'));
--     l_period := l_period || pk_xml_api.create_element('period_month',TO_CHAR(l_workdate,'MM'));
--     l_period := l_period || pk_xml_api.create_element('period_name',TO_CHAR(l_workdate,'MONTH'));
 
     l_process := NULL;
   
     FOR r_stats IN c_stats LOOP
        l_process := l_process || pk_xml_api.create_element('process',pk_xml_api.create_element('proc_id',r_stats.proc_id) ||
                                                       pk_xml_api.create_element('proc_name',r_stats.proc_name) ||
                                                       pk_xml_api.create_element('proc_abbr',r_stats.proc_abbr) ||
                                                       pk_xml_api.create_element('nr_of_proc',r_stats.nr_of_proc)
                                                          );
     END LOOP;
     l_process := pk_xml_api.create_element('processes',l_process);
 
     l_period := l_period || pk_xml_api.create_element('period', pk_xml_api.create_element('period_id','') || -- later vullen als we een tabel hebben
                             pk_xml_api.create_element('period_year',TO_CHAR(l_workdate,'YYYY')) ||
                             pk_xml_api.create_element('period_month',TO_CHAR(l_workdate,'MM')) ||
                             pk_xml_api.create_element('period_name',TO_CHAR(l_workdate,'MONTH')) ||
                             l_process);
     
  END LOOP;
 
  l_response := l_response || pk_xml_api.create_element('periods', l_period);
 
 -- response
 RETURN l_response;
    
END;
 
END PK_API;

